{"version":3,"file":"hotwire_spark.min.js","sources":["../../../node_modules/@rails/actioncable/app/assets/javascripts/actioncable.esm.js","../../javascript/hotwire/spark/channels/consumer.js","../../javascript/hotwire/spark/helpers.js","../../../node_modules/idiomorph/dist/idiomorph.esm.js","../../javascript/hotwire/spark/logger.js","../../../node_modules/@hotwired/stimulus/dist/stimulus.js","../../javascript/hotwire/spark/reloaders/stimulus_reloader.js","../../javascript/hotwire/spark/reloaders/html_reloader.js","../../javascript/hotwire/spark/reloaders/css_reloader.js","../../javascript/hotwire/spark/channels/monitoring_channel.js","../../javascript/hotwire/spark/index.js"],"sourcesContent":["var adapters = {\n  logger: typeof console !== \"undefined\" ? console : undefined,\n  WebSocket: typeof WebSocket !== \"undefined\" ? WebSocket : undefined\n};\n\nvar logger = {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now());\n      adapters.logger.log(\"[ActionCable]\", ...messages);\n    }\n  }\n};\n\nconst now = () => (new Date).getTime();\n\nconst secondsSince = time => (now() - time) / 1e3;\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this);\n    this.connection = connection;\n    this.reconnectAttempts = 0;\n  }\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now();\n      delete this.stoppedAt;\n      this.startPolling();\n      addEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);\n    }\n  }\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now();\n      this.stopPolling();\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange);\n      logger.log(\"ConnectionMonitor stopped\");\n    }\n  }\n  isRunning() {\n    return this.startedAt && !this.stoppedAt;\n  }\n  recordMessage() {\n    this.pingedAt = now();\n  }\n  recordConnect() {\n    this.reconnectAttempts = 0;\n    delete this.disconnectedAt;\n    logger.log(\"ConnectionMonitor recorded connect\");\n  }\n  recordDisconnect() {\n    this.disconnectedAt = now();\n    logger.log(\"ConnectionMonitor recorded disconnect\");\n  }\n  startPolling() {\n    this.stopPolling();\n    this.poll();\n  }\n  stopPolling() {\n    clearTimeout(this.pollTimeout);\n  }\n  poll() {\n    this.pollTimeout = setTimeout((() => {\n      this.reconnectIfStale();\n      this.poll();\n    }), this.getPollInterval());\n  }\n  getPollInterval() {\n    const {staleThreshold: staleThreshold, reconnectionBackoffRate: reconnectionBackoffRate} = this.constructor;\n    const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));\n    const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;\n    const jitter = jitterMax * Math.random();\n    return staleThreshold * 1e3 * backoff * (1 + jitter);\n  }\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);\n      this.reconnectAttempts++;\n      if (this.disconnectedRecently()) {\n        logger.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);\n      } else {\n        logger.log(\"ConnectionMonitor reopening\");\n        this.connection.reopen();\n      }\n    }\n  }\n  get refreshedAt() {\n    return this.pingedAt ? this.pingedAt : this.startedAt;\n  }\n  connectionIsStale() {\n    return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;\n  }\n  disconnectedRecently() {\n    return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;\n  }\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout((() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);\n          this.connection.reopen();\n        }\n      }), 200);\n    }\n  }\n}\n\nConnectionMonitor.staleThreshold = 6;\n\nConnectionMonitor.reconnectionBackoffRate = .15;\n\nvar INTERNAL = {\n  message_types: {\n    welcome: \"welcome\",\n    disconnect: \"disconnect\",\n    ping: \"ping\",\n    confirmation: \"confirm_subscription\",\n    rejection: \"reject_subscription\"\n  },\n  disconnect_reasons: {\n    unauthorized: \"unauthorized\",\n    invalid_request: \"invalid_request\",\n    server_restart: \"server_restart\",\n    remote: \"remote\"\n  },\n  default_mount_path: \"/cable\",\n  protocols: [ \"actioncable-v1-json\", \"actioncable-unsupported\" ]\n};\n\nconst {message_types: message_types, protocols: protocols} = INTERNAL;\n\nconst supportedProtocols = protocols.slice(0, protocols.length - 1);\n\nconst indexOf = [].indexOf;\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this);\n    this.consumer = consumer;\n    this.subscriptions = this.consumer.subscriptions;\n    this.monitor = new ConnectionMonitor(this);\n    this.disconnected = true;\n  }\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data));\n      return true;\n    } else {\n      return false;\n    }\n  }\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);\n      return false;\n    } else {\n      const socketProtocols = [ ...protocols, ...this.consumer.subprotocols || [] ];\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);\n      if (this.webSocket) {\n        this.uninstallEventHandlers();\n      }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, socketProtocols);\n      this.installEventHandlers();\n      this.monitor.start();\n      return true;\n    }\n  }\n  close({allowReconnect: allowReconnect} = {\n    allowReconnect: true\n  }) {\n    if (!allowReconnect) {\n      this.monitor.stop();\n    }\n    if (this.isOpen()) {\n      return this.webSocket.close();\n    }\n  }\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`);\n    if (this.isActive()) {\n      try {\n        return this.close();\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error);\n      } finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);\n        setTimeout(this.open, this.constructor.reopenDelay);\n      }\n    } else {\n      return this.open();\n    }\n  }\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol;\n    }\n  }\n  isOpen() {\n    return this.isState(\"open\");\n  }\n  isActive() {\n    return this.isState(\"open\", \"connecting\");\n  }\n  triedToReconnect() {\n    return this.monitor.reconnectAttempts > 0;\n  }\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;\n  }\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0;\n  }\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase();\n        }\n      }\n    }\n    return null;\n  }\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this);\n      this.webSocket[`on${eventName}`] = handler;\n    }\n  }\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {};\n    }\n  }\n}\n\nConnection.reopenDelay = 500;\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) {\n      return;\n    }\n    const {identifier: identifier, message: message, reason: reason, reconnect: reconnect, type: type} = JSON.parse(event.data);\n    this.monitor.recordMessage();\n    switch (type) {\n     case message_types.welcome:\n      if (this.triedToReconnect()) {\n        this.reconnectAttempted = true;\n      }\n      this.monitor.recordConnect();\n      return this.subscriptions.reload();\n\n     case message_types.disconnect:\n      logger.log(`Disconnecting. Reason: ${reason}`);\n      return this.close({\n        allowReconnect: reconnect\n      });\n\n     case message_types.ping:\n      return null;\n\n     case message_types.confirmation:\n      this.subscriptions.confirmSubscription(identifier);\n      if (this.reconnectAttempted) {\n        this.reconnectAttempted = false;\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: true\n        });\n      } else {\n        return this.subscriptions.notify(identifier, \"connected\", {\n          reconnected: false\n        });\n      }\n\n     case message_types.rejection:\n      return this.subscriptions.reject(identifier);\n\n     default:\n      return this.subscriptions.notify(identifier, \"received\", message);\n    }\n  },\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);\n    this.disconnected = false;\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\");\n      return this.close({\n        allowReconnect: false\n      });\n    }\n  },\n  close(event) {\n    logger.log(\"WebSocket onclose event\");\n    if (this.disconnected) {\n      return;\n    }\n    this.disconnected = true;\n    this.monitor.recordDisconnect();\n    return this.subscriptions.notifyAll(\"disconnected\", {\n      willAttemptReconnect: this.monitor.isRunning()\n    });\n  },\n  error() {\n    logger.log(\"WebSocket onerror event\");\n  }\n};\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key];\n      object[key] = value;\n    }\n  }\n  return object;\n};\n\nclass Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer;\n    this.identifier = JSON.stringify(params);\n    extend(this, mixin);\n  }\n  perform(action, data = {}) {\n    data.action = action;\n    return this.send(data);\n  }\n  send(data) {\n    return this.consumer.send({\n      command: \"message\",\n      identifier: this.identifier,\n      data: JSON.stringify(data)\n    });\n  }\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this);\n  }\n}\n\nclass SubscriptionGuarantor {\n  constructor(subscriptions) {\n    this.subscriptions = subscriptions;\n    this.pendingSubscriptions = [];\n  }\n  guarantee(subscription) {\n    if (this.pendingSubscriptions.indexOf(subscription) == -1) {\n      logger.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);\n      this.pendingSubscriptions.push(subscription);\n    } else {\n      logger.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);\n    }\n    this.startGuaranteeing();\n  }\n  forget(subscription) {\n    logger.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);\n    this.pendingSubscriptions = this.pendingSubscriptions.filter((s => s !== subscription));\n  }\n  startGuaranteeing() {\n    this.stopGuaranteeing();\n    this.retrySubscribing();\n  }\n  stopGuaranteeing() {\n    clearTimeout(this.retryTimeout);\n  }\n  retrySubscribing() {\n    this.retryTimeout = setTimeout((() => {\n      if (this.subscriptions && typeof this.subscriptions.subscribe === \"function\") {\n        this.pendingSubscriptions.map((subscription => {\n          logger.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);\n          this.subscriptions.subscribe(subscription);\n        }));\n      }\n    }), 500);\n  }\n}\n\nclass Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer;\n    this.guarantor = new SubscriptionGuarantor(this);\n    this.subscriptions = [];\n  }\n  create(channelName, mixin) {\n    const channel = channelName;\n    const params = typeof channel === \"object\" ? channel : {\n      channel: channel\n    };\n    const subscription = new Subscription(this.consumer, params, mixin);\n    return this.add(subscription);\n  }\n  add(subscription) {\n    this.subscriptions.push(subscription);\n    this.consumer.ensureActiveConnection();\n    this.notify(subscription, \"initialized\");\n    this.subscribe(subscription);\n    return subscription;\n  }\n  remove(subscription) {\n    this.forget(subscription);\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\");\n    }\n    return subscription;\n  }\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription => {\n      this.forget(subscription);\n      this.notify(subscription, \"rejected\");\n      return subscription;\n    }));\n  }\n  forget(subscription) {\n    this.guarantor.forget(subscription);\n    this.subscriptions = this.subscriptions.filter((s => s !== subscription));\n    return subscription;\n  }\n  findAll(identifier) {\n    return this.subscriptions.filter((s => s.identifier === identifier));\n  }\n  reload() {\n    return this.subscriptions.map((subscription => this.subscribe(subscription)));\n  }\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription => this.notify(subscription, callbackName, ...args)));\n  }\n  notify(subscription, callbackName, ...args) {\n    let subscriptions;\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription);\n    } else {\n      subscriptions = [ subscription ];\n    }\n    return subscriptions.map((subscription => typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined));\n  }\n  subscribe(subscription) {\n    if (this.sendCommand(subscription, \"subscribe\")) {\n      this.guarantor.guarantee(subscription);\n    }\n  }\n  confirmSubscription(identifier) {\n    logger.log(`Subscription confirmed ${identifier}`);\n    this.findAll(identifier).map((subscription => this.guarantor.forget(subscription)));\n  }\n  sendCommand(subscription, command) {\n    const {identifier: identifier} = subscription;\n    return this.consumer.send({\n      command: command,\n      identifier: identifier\n    });\n  }\n}\n\nclass Consumer {\n  constructor(url) {\n    this._url = url;\n    this.subscriptions = new Subscriptions(this);\n    this.connection = new Connection(this);\n    this.subprotocols = [];\n  }\n  get url() {\n    return createWebSocketURL(this._url);\n  }\n  send(data) {\n    return this.connection.send(data);\n  }\n  connect() {\n    return this.connection.open();\n  }\n  disconnect() {\n    return this.connection.close({\n      allowReconnect: false\n    });\n  }\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open();\n    }\n  }\n  addSubProtocol(subprotocol) {\n    this.subprotocols = [ ...this.subprotocols, subprotocol ];\n  }\n}\n\nfunction createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url();\n  }\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.href = a.href;\n    a.protocol = a.protocol.replace(\"http\", \"ws\");\n    return a.href;\n  } else {\n    return url;\n  }\n}\n\nfunction createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url);\n}\n\nfunction getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`);\n  if (element) {\n    return element.getAttribute(\"content\");\n  }\n}\n\nexport { Connection, ConnectionMonitor, Consumer, INTERNAL, Subscription, SubscriptionGuarantor, Subscriptions, adapters, createConsumer, createWebSocketURL, getConfig, logger };\n","import { createConsumer } from \"@rails/actioncable\"\n\nexport default createConsumer(\"/hotwire-spark\")\n","export function assetNameFromPath(path) {\n  return path.split(\"/\").pop().split(\".\")[0]\n}\n\nexport function pathWithoutAssetDigest(path) {\n  return path.replace(/-[a-z0-9]+\\.(\\w+)(\\?.*)?$/, \".$1\")\n}\n\nexport function urlWithParams(urlString, params) {\n  const url = new URL(urlString, window.location.origin)\n  Object.entries(params).forEach(([ key, value ]) => {\n    url.searchParams.set(key, value)\n  })\n  return url.toString()\n}\n\nexport function cacheBustedUrl(urlString) {\n  return urlWithParams(urlString, { reload: Date.now() })\n}\n\nexport async function reloadHtmlDocument() {\n  let currentUrl = cacheBustedUrl(urlWithParams(window.location.href, { hotwire_spark: \"true\" }))\n  const response = await fetch(currentUrl, { headers: { \"Accept\": \"text/html\" }})\n\n  if (!response.ok) {\n    throw new Error(`${response.status} when fetching ${currentUrl}`)\n  }\n\n  const fetchedHTML = await response.text()\n  const parser = new DOMParser()\n  return parser.parseFromString(fetchedHTML, \"text/html\")\n}\n\nexport function getConfigurationProperty(name) {\n  return document.querySelector(`meta[name=\"hotwire-spark:${name}\"]`)?.content\n}\n\n","// base IIFE to define idiomorph\nvar Idiomorph = (function () {\n        'use strict';\n\n        //=============================================================================\n        // AND NOW IT BEGINS...\n        //=============================================================================\n        let EMPTY_SET = new Set();\n\n        // default configuration values, updatable by users now\n        let defaults = {\n            morphStyle: \"outerHTML\",\n            callbacks : {\n                beforeNodeAdded: noOp,\n                afterNodeAdded: noOp,\n                beforeNodeMorphed: noOp,\n                afterNodeMorphed: noOp,\n                beforeNodeRemoved: noOp,\n                afterNodeRemoved: noOp,\n                beforeAttributeUpdated: noOp,\n\n            },\n            head: {\n                style: 'merge',\n                shouldPreserve: function (elt) {\n                    return elt.getAttribute(\"im-preserve\") === \"true\";\n                },\n                shouldReAppend: function (elt) {\n                    return elt.getAttribute(\"im-re-append\") === \"true\";\n                },\n                shouldRemove: noOp,\n                afterHeadMorphed: noOp,\n            }\n        };\n\n        //=============================================================================\n        // Core Morphing Algorithm - morph, morphNormalizedContent, morphOldNodeTo, morphChildren\n        //=============================================================================\n        function morph(oldNode, newContent, config = {}) {\n\n            if (oldNode instanceof Document) {\n                oldNode = oldNode.documentElement;\n            }\n\n            if (typeof newContent === 'string') {\n                newContent = parseContent(newContent);\n            }\n\n            let normalizedContent = normalizeContent(newContent);\n\n            let ctx = createMorphContext(oldNode, normalizedContent, config);\n\n            return morphNormalizedContent(oldNode, normalizedContent, ctx);\n        }\n\n        function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {\n            if (ctx.head.block) {\n                let oldHead = oldNode.querySelector('head');\n                let newHead = normalizedNewContent.querySelector('head');\n                if (oldHead && newHead) {\n                    let promises = handleHeadElement(newHead, oldHead, ctx);\n                    // when head promises resolve, call morph again, ignoring the head tag\n                    Promise.all(promises).then(function () {\n                        morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx, {\n                            head: {\n                                block: false,\n                                ignore: true\n                            }\n                        }));\n                    });\n                    return;\n                }\n            }\n\n            if (ctx.morphStyle === \"innerHTML\") {\n\n                // innerHTML, so we are only updating the children\n                morphChildren(normalizedNewContent, oldNode, ctx);\n                return oldNode.children;\n\n            } else if (ctx.morphStyle === \"outerHTML\" || ctx.morphStyle == null) {\n                // otherwise find the best element match in the new content, morph that, and merge its siblings\n                // into either side of the best match\n                let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx);\n\n                // stash the siblings that will need to be inserted on either side of the best match\n                let previousSibling = bestMatch?.previousSibling;\n                let nextSibling = bestMatch?.nextSibling;\n\n                // morph it\n                let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);\n\n                if (bestMatch) {\n                    // if there was a best match, merge the siblings in too and return the\n                    // whole bunch\n                    return insertSiblings(previousSibling, morphedNode, nextSibling);\n                } else {\n                    // otherwise nothing was added to the DOM\n                    return []\n                }\n            } else {\n                throw \"Do not understand how to morph style \" + ctx.morphStyle;\n            }\n        }\n\n\n        /**\n         * @param possibleActiveElement\n         * @param ctx\n         * @returns {boolean}\n         */\n        function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n            return ctx.ignoreActiveValue && possibleActiveElement === document.activeElement;\n        }\n\n        /**\n         * @param oldNode root node to merge content into\n         * @param newContent new content to merge\n         * @param ctx the merge context\n         * @returns {Element} the element that ended up in the DOM\n         */\n        function morphOldNodeTo(oldNode, newContent, ctx) {\n            if (ctx.ignoreActive && oldNode === document.activeElement) {\n                // don't morph focused element\n            } else if (newContent == null) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n\n                oldNode.remove();\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return null;\n            } else if (!isSoftMatch(oldNode, newContent)) {\n                if (ctx.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;\n                if (ctx.callbacks.beforeNodeAdded(newContent) === false) return oldNode;\n\n                oldNode.parentElement.replaceChild(newContent, oldNode);\n                ctx.callbacks.afterNodeAdded(newContent);\n                ctx.callbacks.afterNodeRemoved(oldNode);\n                return newContent;\n            } else {\n                if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;\n\n                if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n                    // ignore the head element\n                } else if (oldNode instanceof HTMLHeadElement && ctx.head.style !== \"morph\") {\n                    handleHeadElement(newContent, oldNode, ctx);\n                } else {\n                    syncNodeFrom(newContent, oldNode, ctx);\n                    if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n                        morphChildren(newContent, oldNode, ctx);\n                    }\n                }\n                ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n                return oldNode;\n            }\n        }\n\n        /**\n         * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n         * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n         * by using id sets, we are able to better match up with content deeper in the DOM.\n         *\n         * Basic algorithm is, for each node in the new content:\n         *\n         * - if we have reached the end of the old parent, append the new content\n         * - if the new content has an id set match with the current insertion point, morph\n         * - search for an id set match\n         * - if id set match found, morph\n         * - otherwise search for a \"soft\" match\n         * - if a soft match is found, morph\n         * - otherwise, prepend the new node before the current insertion point\n         *\n         * The two search algorithms terminate if competing node matches appear to outweigh what can be achieved\n         * with the current node.  See findIdSetMatch() and findSoftMatch() for details.\n         *\n         * @param {Element} newParent the parent element of the new content\n         * @param {Element } oldParent the old content that we are merging the new content into\n         * @param ctx the merge context\n         */\n        function morphChildren(newParent, oldParent, ctx) {\n\n            let nextNewChild = newParent.firstChild;\n            let insertionPoint = oldParent.firstChild;\n            let newChild;\n\n            // run through all the new content\n            while (nextNewChild) {\n\n                newChild = nextNewChild;\n                nextNewChild = newChild.nextSibling;\n\n                // if we are at the end of the exiting parent's children, just append\n                if (insertionPoint == null) {\n                    if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                    oldParent.appendChild(newChild);\n                    ctx.callbacks.afterNodeAdded(newChild);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // if the current node has an id set match then morph\n                if (isIdSetMatch(newChild, insertionPoint, ctx)) {\n                    morphOldNodeTo(insertionPoint, newChild, ctx);\n                    insertionPoint = insertionPoint.nextSibling;\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // otherwise search forward in the existing old children for an id set match\n                let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a potential match, remove the nodes until that point and morph\n                if (idSetMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx);\n                    morphOldNodeTo(idSetMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // no id set match found, so scan forward for a soft match for the current node\n                let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx);\n\n                // if we found a soft match for the current node, morph\n                if (softMatch) {\n                    insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx);\n                    morphOldNodeTo(softMatch, newChild, ctx);\n                    removeIdsFromConsideration(ctx, newChild);\n                    continue;\n                }\n\n                // abandon all hope of morphing, just insert the new child before the insertion point\n                // and move on\n                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;\n\n                oldParent.insertBefore(newChild, insertionPoint);\n                ctx.callbacks.afterNodeAdded(newChild);\n                removeIdsFromConsideration(ctx, newChild);\n            }\n\n            // remove any remaining old nodes that didn't match up with new content\n            while (insertionPoint !== null) {\n\n                let tempNode = insertionPoint;\n                insertionPoint = insertionPoint.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n        }\n\n        //=============================================================================\n        // Attribute Syncing Code\n        //=============================================================================\n\n        /**\n         * @param attr {String} the attribute to be mutated\n         * @param to {Element} the element that is going to be updated\n         * @param updateType {(\"update\"|\"remove\")}\n         * @param ctx the merge context\n         * @returns {boolean} true if the attribute should be ignored, false otherwise\n         */\n        function ignoreAttribute(attr, to, updateType, ctx) {\n            if(attr === 'value' && ctx.ignoreActiveValue && to === document.activeElement){\n                return true;\n            }\n            return ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false;\n        }\n\n        /**\n         * syncs a given node with another node, copying over all attributes and\n         * inner element state from the 'from' node to the 'to' node\n         *\n         * @param {Element} from the element to copy attributes & state from\n         * @param {Element} to the element to copy attributes & state to\n         * @param ctx the merge context\n         */\n        function syncNodeFrom(from, to, ctx) {\n            let type = from.nodeType\n\n            // if is an element type, sync the attributes from the\n            // new node into the new node\n            if (type === 1 /* element type */) {\n                const fromAttributes = from.attributes;\n                const toAttributes = to.attributes;\n                for (const fromAttribute of fromAttributes) {\n                    if (ignoreAttribute(fromAttribute.name, to, 'update', ctx)) {\n                        continue;\n                    }\n                    if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {\n                        to.setAttribute(fromAttribute.name, fromAttribute.value);\n                    }\n                }\n                // iterate backwards to avoid skipping over items when a delete occurs\n                for (let i = toAttributes.length - 1; 0 <= i; i--) {\n                    const toAttribute = toAttributes[i];\n                    if (ignoreAttribute(toAttribute.name, to, 'remove', ctx)) {\n                        continue;\n                    }\n                    if (!from.hasAttribute(toAttribute.name)) {\n                        to.removeAttribute(toAttribute.name);\n                    }\n                }\n            }\n\n            // sync text nodes\n            if (type === 8 /* comment */ || type === 3 /* text */) {\n                if (to.nodeValue !== from.nodeValue) {\n                    to.nodeValue = from.nodeValue;\n                }\n            }\n\n            if (!ignoreValueOfActiveElement(to, ctx)) {\n                // sync input values\n                syncInputValue(from, to, ctx);\n            }\n        }\n\n        /**\n         * @param from {Element} element to sync the value from\n         * @param to {Element} element to sync the value to\n         * @param attributeName {String} the attribute name\n         * @param ctx the merge context\n         */\n        function syncBooleanAttribute(from, to, attributeName, ctx) {\n            if (from[attributeName] !== to[attributeName]) {\n                let ignoreUpdate = ignoreAttribute(attributeName, to, 'update', ctx);\n                if (!ignoreUpdate) {\n                    to[attributeName] = from[attributeName];\n                }\n                if (from[attributeName]) {\n                    if (!ignoreUpdate) {\n                        to.setAttribute(attributeName, from[attributeName]);\n                    }\n                } else {\n                    if (!ignoreAttribute(attributeName, to, 'remove', ctx)) {\n                        to.removeAttribute(attributeName);\n                    }\n                }\n            }\n        }\n\n        /**\n         * NB: many bothans died to bring us information:\n         *\n         *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n         *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n         *\n         * @param from {Element} the element to sync the input value from\n         * @param to {Element} the element to sync the input value to\n         * @param ctx the merge context\n         */\n        function syncInputValue(from, to, ctx) {\n            if (from instanceof HTMLInputElement &&\n                to instanceof HTMLInputElement &&\n                from.type !== 'file') {\n\n                let fromValue = from.value;\n                let toValue = to.value;\n\n                // sync boolean attributes\n                syncBooleanAttribute(from, to, 'checked', ctx);\n                syncBooleanAttribute(from, to, 'disabled', ctx);\n\n                if (!from.hasAttribute('value')) {\n                    if (!ignoreAttribute('value', to, 'remove', ctx)) {\n                        to.value = '';\n                        to.removeAttribute('value');\n                    }\n                } else if (fromValue !== toValue) {\n                    if (!ignoreAttribute('value', to, 'update', ctx)) {\n                        to.setAttribute('value', fromValue);\n                        to.value = fromValue;\n                    }\n                }\n            } else if (from instanceof HTMLOptionElement) {\n                syncBooleanAttribute(from, to, 'selected', ctx)\n            } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {\n                let fromValue = from.value;\n                let toValue = to.value;\n                if (ignoreAttribute('value', to, 'update', ctx)) {\n                    return;\n                }\n                if (fromValue !== toValue) {\n                    to.value = fromValue;\n                }\n                if (to.firstChild && to.firstChild.nodeValue !== fromValue) {\n                    to.firstChild.nodeValue = fromValue\n                }\n            }\n        }\n\n        //=============================================================================\n        // the HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n        //=============================================================================\n        function handleHeadElement(newHeadTag, currentHead, ctx) {\n\n            let added = []\n            let removed = []\n            let preserved = []\n            let nodesToAppend = []\n\n            let headMergeStyle = ctx.head.style;\n\n            // put all new head elements into a Map, by their outerHTML\n            let srcToNewHeadNodes = new Map();\n            for (const newHeadChild of newHeadTag.children) {\n                srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n            }\n\n            // for each elt in the current head\n            for (const currentHeadElt of currentHead.children) {\n\n                // If the current head element is in the map\n                let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n                let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n                let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n                if (inNewContent || isPreserved) {\n                    if (isReAppended) {\n                        // remove the current version and let the new version replace it and re-execute\n                        removed.push(currentHeadElt);\n                    } else {\n                        // this element already exists and should not be re-appended, so remove it from\n                        // the new content map, preserving it in the DOM\n                        srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n                        preserved.push(currentHeadElt);\n                    }\n                } else {\n                    if (headMergeStyle === \"append\") {\n                        // we are appending and this existing element is not new content\n                        // so if and only if it is marked for re-append do we do anything\n                        if (isReAppended) {\n                            removed.push(currentHeadElt);\n                            nodesToAppend.push(currentHeadElt);\n                        }\n                    } else {\n                        // if this is a merge, we remove this content since it is not in the new head\n                        if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n                            removed.push(currentHeadElt);\n                        }\n                    }\n                }\n            }\n\n            // Push the remaining new head elements in the Map into the\n            // nodes to append to the head tag\n            nodesToAppend.push(...srcToNewHeadNodes.values());\n            log(\"to append: \", nodesToAppend);\n\n            let promises = [];\n            for (const newNode of nodesToAppend) {\n                log(\"adding: \", newNode);\n                let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;\n                log(newElt);\n                if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n                    if (newElt.href || newElt.src) {\n                        let resolve = null;\n                        let promise = new Promise(function (_resolve) {\n                            resolve = _resolve;\n                        });\n                        newElt.addEventListener('load', function () {\n                            resolve();\n                        });\n                        promises.push(promise);\n                    }\n                    currentHead.appendChild(newElt);\n                    ctx.callbacks.afterNodeAdded(newElt);\n                    added.push(newElt);\n                }\n            }\n\n            // remove all removed elements, after we have appended the new elements to avoid\n            // additional network requests for things like style sheets\n            for (const removedElement of removed) {\n                if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n                    currentHead.removeChild(removedElement);\n                    ctx.callbacks.afterNodeRemoved(removedElement);\n                }\n            }\n\n            ctx.head.afterHeadMorphed(currentHead, {added: added, kept: preserved, removed: removed});\n            return promises;\n        }\n\n        //=============================================================================\n        // Misc\n        //=============================================================================\n\n        function log() {\n            //console.log(arguments);\n        }\n\n        function noOp() {\n        }\n\n        /*\n          Deep merges the config object and the Idiomoroph.defaults object to\n          produce a final configuration object\n         */\n        function mergeDefaults(config) {\n            let finalConfig = {};\n            // copy top level stuff into final config\n            Object.assign(finalConfig, defaults);\n            Object.assign(finalConfig, config);\n\n            // copy callbacks into final config (do this to deep merge the callbacks)\n            finalConfig.callbacks = {};\n            Object.assign(finalConfig.callbacks, defaults.callbacks);\n            Object.assign(finalConfig.callbacks, config.callbacks);\n\n            // copy head config into final config  (do this to deep merge the head)\n            finalConfig.head = {};\n            Object.assign(finalConfig.head, defaults.head);\n            Object.assign(finalConfig.head, config.head);\n            return finalConfig;\n        }\n\n        function createMorphContext(oldNode, newContent, config) {\n            config = mergeDefaults(config);\n            return {\n                target: oldNode,\n                newContent: newContent,\n                config: config,\n                morphStyle: config.morphStyle,\n                ignoreActive: config.ignoreActive,\n                ignoreActiveValue: config.ignoreActiveValue,\n                idMap: createIdMap(oldNode, newContent),\n                deadIds: new Set(),\n                callbacks: config.callbacks,\n                head: config.head\n            }\n        }\n\n        function isIdSetMatch(node1, node2, ctx) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {\n                if (node1.id !== \"\" && node1.id === node2.id) {\n                    return true;\n                } else {\n                    return getIdIntersectionCount(ctx, node1, node2) > 0;\n                }\n            }\n            return false;\n        }\n\n        function isSoftMatch(node1, node2) {\n            if (node1 == null || node2 == null) {\n                return false;\n            }\n            return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName\n        }\n\n        function removeNodesBetween(startInclusive, endExclusive, ctx) {\n            while (startInclusive !== endExclusive) {\n                let tempNode = startInclusive;\n                startInclusive = startInclusive.nextSibling;\n                removeNode(tempNode, ctx);\n            }\n            removeIdsFromConsideration(ctx, endExclusive);\n            return endExclusive.nextSibling;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential id match\n        // for the newChild.  We stop if we find a potential id match for the new child OR\n        // if the number of potential id matches we are discarding is greater than the\n        // potential id matches for the new child\n        //=============================================================================\n        function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            // max id matches we are willing to discard in our search\n            let newChildPotentialIdCount = getIdIntersectionCount(ctx, newChild, oldParent);\n\n            let potentialMatch = null;\n\n            // only search forward if there is a possibility of an id match\n            if (newChildPotentialIdCount > 0) {\n                let potentialMatch = insertionPoint;\n                // if there is a possibility of an id match, scan forward\n                // keep track of the potential id match count we are discarding (the\n                // newChildPotentialIdCount must be greater than this to make it likely\n                // worth it)\n                let otherMatchCount = 0;\n                while (potentialMatch != null) {\n\n                    // If we have an id match, return the current potential match\n                    if (isIdSetMatch(newChild, potentialMatch, ctx)) {\n                        return potentialMatch;\n                    }\n\n                    // computer the other potential matches of this new content\n                    otherMatchCount += getIdIntersectionCount(ctx, potentialMatch, newContent);\n                    if (otherMatchCount > newChildPotentialIdCount) {\n                        // if we have more potential id matches in _other_ content, we\n                        // do not have a good candidate for an id match, so return null\n                        return null;\n                    }\n\n                    // advanced to the next old content child\n                    potentialMatch = potentialMatch.nextSibling;\n                }\n            }\n            return potentialMatch;\n        }\n\n        //=============================================================================\n        // Scans forward from the insertionPoint in the old parent looking for a potential soft match\n        // for the newChild.  We stop if we find a potential soft match for the new child OR\n        // if we find a potential id match in the old parents children OR if we find two\n        // potential soft matches for the next two pieces of new content\n        //=============================================================================\n        function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx) {\n\n            let potentialSoftMatch = insertionPoint;\n            let nextSibling = newChild.nextSibling;\n            let siblingSoftMatchCount = 0;\n\n            while (potentialSoftMatch != null) {\n\n                if (getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0) {\n                    // the current potential soft match has a potential id set match with the remaining new\n                    // content so bail out of looking\n                    return null;\n                }\n\n                // if we have a soft match with the current node, return it\n                if (isSoftMatch(newChild, potentialSoftMatch)) {\n                    return potentialSoftMatch;\n                }\n\n                if (isSoftMatch(nextSibling, potentialSoftMatch)) {\n                    // the next new node has a soft match with this node, so\n                    // increment the count of future soft matches\n                    siblingSoftMatchCount++;\n                    nextSibling = nextSibling.nextSibling;\n\n                    // If there are two future soft matches, bail to allow the siblings to soft match\n                    // so that we don't consume future soft matches for the sake of the current node\n                    if (siblingSoftMatchCount >= 2) {\n                        return null;\n                    }\n                }\n\n                // advanced to the next old content child\n                potentialSoftMatch = potentialSoftMatch.nextSibling;\n            }\n\n            return potentialSoftMatch;\n        }\n\n        function parseContent(newContent) {\n            let parser = new DOMParser();\n\n            // remove svgs to avoid false-positive matches on head, etc.\n            let contentWithSvgsRemoved = newContent.replace(/<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim, '');\n\n            // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n            if (contentWithSvgsRemoved.match(/<\\/html>/) || contentWithSvgsRemoved.match(/<\\/head>/) || contentWithSvgsRemoved.match(/<\\/body>/)) {\n                let content = parser.parseFromString(newContent, \"text/html\");\n                // if it is a full HTML document, return the document itself as the parent container\n                if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n                    content.generatedByIdiomorph = true;\n                    return content;\n                } else {\n                    // otherwise return the html element as the parent container\n                    let htmlElement = content.firstChild;\n                    if (htmlElement) {\n                        htmlElement.generatedByIdiomorph = true;\n                        return htmlElement;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n                // deal with touchy tags like tr, tbody, etc.\n                let responseDoc = parser.parseFromString(\"<body><template>\" + newContent + \"</template></body>\", \"text/html\");\n                let content = responseDoc.body.querySelector('template').content;\n                content.generatedByIdiomorph = true;\n                return content\n            }\n        }\n\n        function normalizeContent(newContent) {\n            if (newContent == null) {\n                // noinspection UnnecessaryLocalVariableJS\n                const dummyParent = document.createElement('div');\n                return dummyParent;\n            } else if (newContent.generatedByIdiomorph) {\n                // the template tag created by idiomorph parsing can serve as a dummy parent\n                return newContent;\n            } else if (newContent instanceof Node) {\n                // a single node is added as a child to a dummy parent\n                const dummyParent = document.createElement('div');\n                dummyParent.append(newContent);\n                return dummyParent;\n            } else {\n                // all nodes in the array or HTMLElement collection are consolidated under\n                // a single dummy parent element\n                const dummyParent = document.createElement('div');\n                for (const elt of [...newContent]) {\n                    dummyParent.append(elt);\n                }\n                return dummyParent;\n            }\n        }\n\n        function insertSiblings(previousSibling, morphedNode, nextSibling) {\n            let stack = []\n            let added = []\n            while (previousSibling != null) {\n                stack.push(previousSibling);\n                previousSibling = previousSibling.previousSibling;\n            }\n            while (stack.length > 0) {\n                let node = stack.pop();\n                added.push(node); // push added preceding siblings on in order and insert\n                morphedNode.parentElement.insertBefore(node, morphedNode);\n            }\n            added.push(morphedNode);\n            while (nextSibling != null) {\n                stack.push(nextSibling);\n                added.push(nextSibling); // here we are going in order, so push on as we scan, rather than add\n                nextSibling = nextSibling.nextSibling;\n            }\n            while (stack.length > 0) {\n                morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);\n            }\n            return added;\n        }\n\n        function findBestNodeMatch(newContent, oldNode, ctx) {\n            let currentElement;\n            currentElement = newContent.firstChild;\n            let bestElement = currentElement;\n            let score = 0;\n            while (currentElement) {\n                let newScore = scoreElement(currentElement, oldNode, ctx);\n                if (newScore > score) {\n                    bestElement = currentElement;\n                    score = newScore;\n                }\n                currentElement = currentElement.nextSibling;\n            }\n            return bestElement;\n        }\n\n        function scoreElement(node1, node2, ctx) {\n            if (isSoftMatch(node1, node2)) {\n                return .5 + getIdIntersectionCount(ctx, node1, node2);\n            }\n            return 0;\n        }\n\n        function removeNode(tempNode, ctx) {\n            removeIdsFromConsideration(ctx, tempNode)\n            if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;\n\n            tempNode.remove();\n            ctx.callbacks.afterNodeRemoved(tempNode);\n        }\n\n        //=============================================================================\n        // ID Set Functions\n        //=============================================================================\n\n        function isIdInConsideration(ctx, id) {\n            return !ctx.deadIds.has(id);\n        }\n\n        function idIsWithinNode(ctx, id, targetNode) {\n            let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;\n            return idSet.has(id);\n        }\n\n        function removeIdsFromConsideration(ctx, node) {\n            let idSet = ctx.idMap.get(node) || EMPTY_SET;\n            for (const id of idSet) {\n                ctx.deadIds.add(id);\n            }\n        }\n\n        function getIdIntersectionCount(ctx, node1, node2) {\n            let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;\n            let matchCount = 0;\n            for (const id of sourceSet) {\n                // a potential match is an id in the source and potentialIdsSet, but\n                // that has not already been merged into the DOM\n                if (isIdInConsideration(ctx, id) && idIsWithinNode(ctx, id, node2)) {\n                    ++matchCount;\n                }\n            }\n            return matchCount;\n        }\n\n        /**\n         * A bottom up algorithm that finds all elements with ids inside of the node\n         * argument and populates id sets for those nodes and all their parents, generating\n         * a set of ids contained within all nodes for the entire hierarchy in the DOM\n         *\n         * @param node {Element}\n         * @param {Map<Node, Set<String>>} idMap\n         */\n        function populateIdMapForNode(node, idMap) {\n            let nodeParent = node.parentElement;\n            // find all elements with an id property\n            let idElements = node.querySelectorAll('[id]');\n            for (const elt of idElements) {\n                let current = elt;\n                // walk up the parent hierarchy of that element, adding the id\n                // of element to the parent's id set\n                while (current !== nodeParent && current != null) {\n                    let idSet = idMap.get(current);\n                    // if the id set doesn't exist, create it and insert it in the  map\n                    if (idSet == null) {\n                        idSet = new Set();\n                        idMap.set(current, idSet);\n                    }\n                    idSet.add(elt.id);\n                    current = current.parentElement;\n                }\n            }\n        }\n\n        /**\n         * This function computes a map of nodes to all ids contained within that node (inclusive of the\n         * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n         * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n         * to contribute to a parent nodes matching.\n         *\n         * @param {Element} oldContent  the old content that will be morphed\n         * @param {Element} newContent  the new content to morph to\n         * @returns {Map<Node, Set<String>>} a map of nodes to id sets for the\n         */\n        function createIdMap(oldContent, newContent) {\n            let idMap = new Map();\n            populateIdMapForNode(oldContent, idMap);\n            populateIdMapForNode(newContent, idMap);\n            return idMap;\n        }\n\n        //=============================================================================\n        // This is what ends up becoming the Idiomorph global object\n        //=============================================================================\n        return {\n            morph,\n            defaults\n        }\n    })();\n\nexport {Idiomorph};\n","import HotwireSpark from \"./index.js\"\n\nexport function log(...args) {\n  if (HotwireSpark.config.loggingEnabled) {\n    console.log(`[hotwire_spark]`, ...args)\n  }\n}\n\n","/*\nStimulus 3.2.1\nCopyright © 2023 Basecamp, LLC\n */\nclass EventListener {\n    constructor(eventTarget, eventName, eventOptions) {\n        this.eventTarget = eventTarget;\n        this.eventName = eventName;\n        this.eventOptions = eventOptions;\n        this.unorderedBindings = new Set();\n    }\n    connect() {\n        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);\n    }\n    disconnect() {\n        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);\n    }\n    bindingConnected(binding) {\n        this.unorderedBindings.add(binding);\n    }\n    bindingDisconnected(binding) {\n        this.unorderedBindings.delete(binding);\n    }\n    handleEvent(event) {\n        const extendedEvent = extendEvent(event);\n        for (const binding of this.bindings) {\n            if (extendedEvent.immediatePropagationStopped) {\n                break;\n            }\n            else {\n                binding.handleEvent(extendedEvent);\n            }\n        }\n    }\n    hasBindings() {\n        return this.unorderedBindings.size > 0;\n    }\n    get bindings() {\n        return Array.from(this.unorderedBindings).sort((left, right) => {\n            const leftIndex = left.index, rightIndex = right.index;\n            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;\n        });\n    }\n}\nfunction extendEvent(event) {\n    if (\"immediatePropagationStopped\" in event) {\n        return event;\n    }\n    else {\n        const { stopImmediatePropagation } = event;\n        return Object.assign(event, {\n            immediatePropagationStopped: false,\n            stopImmediatePropagation() {\n                this.immediatePropagationStopped = true;\n                stopImmediatePropagation.call(this);\n            },\n        });\n    }\n}\n\nclass Dispatcher {\n    constructor(application) {\n        this.application = application;\n        this.eventListenerMaps = new Map();\n        this.started = false;\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.eventListeners.forEach((eventListener) => eventListener.connect());\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.started = false;\n            this.eventListeners.forEach((eventListener) => eventListener.disconnect());\n        }\n    }\n    get eventListeners() {\n        return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);\n    }\n    bindingConnected(binding) {\n        this.fetchEventListenerForBinding(binding).bindingConnected(binding);\n    }\n    bindingDisconnected(binding, clearEventListeners = false) {\n        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);\n        if (clearEventListeners)\n            this.clearEventListenersForBinding(binding);\n    }\n    handleError(error, message, detail = {}) {\n        this.application.handleError(error, `Error ${message}`, detail);\n    }\n    clearEventListenersForBinding(binding) {\n        const eventListener = this.fetchEventListenerForBinding(binding);\n        if (!eventListener.hasBindings()) {\n            eventListener.disconnect();\n            this.removeMappedEventListenerFor(binding);\n        }\n    }\n    removeMappedEventListenerFor(binding) {\n        const { eventTarget, eventName, eventOptions } = binding;\n        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n        const cacheKey = this.cacheKey(eventName, eventOptions);\n        eventListenerMap.delete(cacheKey);\n        if (eventListenerMap.size == 0)\n            this.eventListenerMaps.delete(eventTarget);\n    }\n    fetchEventListenerForBinding(binding) {\n        const { eventTarget, eventName, eventOptions } = binding;\n        return this.fetchEventListener(eventTarget, eventName, eventOptions);\n    }\n    fetchEventListener(eventTarget, eventName, eventOptions) {\n        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n        const cacheKey = this.cacheKey(eventName, eventOptions);\n        let eventListener = eventListenerMap.get(cacheKey);\n        if (!eventListener) {\n            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);\n            eventListenerMap.set(cacheKey, eventListener);\n        }\n        return eventListener;\n    }\n    createEventListener(eventTarget, eventName, eventOptions) {\n        const eventListener = new EventListener(eventTarget, eventName, eventOptions);\n        if (this.started) {\n            eventListener.connect();\n        }\n        return eventListener;\n    }\n    fetchEventListenerMapForEventTarget(eventTarget) {\n        let eventListenerMap = this.eventListenerMaps.get(eventTarget);\n        if (!eventListenerMap) {\n            eventListenerMap = new Map();\n            this.eventListenerMaps.set(eventTarget, eventListenerMap);\n        }\n        return eventListenerMap;\n    }\n    cacheKey(eventName, eventOptions) {\n        const parts = [eventName];\n        Object.keys(eventOptions)\n            .sort()\n            .forEach((key) => {\n            parts.push(`${eventOptions[key] ? \"\" : \"!\"}${key}`);\n        });\n        return parts.join(\":\");\n    }\n}\n\nconst defaultActionDescriptorFilters = {\n    stop({ event, value }) {\n        if (value)\n            event.stopPropagation();\n        return true;\n    },\n    prevent({ event, value }) {\n        if (value)\n            event.preventDefault();\n        return true;\n    },\n    self({ event, value, element }) {\n        if (value) {\n            return element === event.target;\n        }\n        else {\n            return true;\n        }\n    },\n};\nconst descriptorPattern = /^(?:(?:([^.]+?)\\+)?(.+?)(?:\\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;\nfunction parseActionDescriptorString(descriptorString) {\n    const source = descriptorString.trim();\n    const matches = source.match(descriptorPattern) || [];\n    let eventName = matches[2];\n    let keyFilter = matches[3];\n    if (keyFilter && ![\"keydown\", \"keyup\", \"keypress\"].includes(eventName)) {\n        eventName += `.${keyFilter}`;\n        keyFilter = \"\";\n    }\n    return {\n        eventTarget: parseEventTarget(matches[4]),\n        eventName,\n        eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},\n        identifier: matches[5],\n        methodName: matches[6],\n        keyFilter: matches[1] || keyFilter,\n    };\n}\nfunction parseEventTarget(eventTargetName) {\n    if (eventTargetName == \"window\") {\n        return window;\n    }\n    else if (eventTargetName == \"document\") {\n        return document;\n    }\n}\nfunction parseEventOptions(eventOptions) {\n    return eventOptions\n        .split(\":\")\n        .reduce((options, token) => Object.assign(options, { [token.replace(/^!/, \"\")]: !/^!/.test(token) }), {});\n}\nfunction stringifyEventTarget(eventTarget) {\n    if (eventTarget == window) {\n        return \"window\";\n    }\n    else if (eventTarget == document) {\n        return \"document\";\n    }\n}\n\nfunction camelize(value) {\n    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());\n}\nfunction namespaceCamelize(value) {\n    return camelize(value.replace(/--/g, \"-\").replace(/__/g, \"_\"));\n}\nfunction capitalize(value) {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n}\nfunction dasherize(value) {\n    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);\n}\nfunction tokenize(value) {\n    return value.match(/[^\\s]+/g) || [];\n}\n\nfunction isSomething(object) {\n    return object !== null && object !== undefined;\n}\nfunction hasProperty(object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n}\n\nconst allModifiers = [\"meta\", \"ctrl\", \"alt\", \"shift\"];\nclass Action {\n    constructor(element, index, descriptor, schema) {\n        this.element = element;\n        this.index = index;\n        this.eventTarget = descriptor.eventTarget || element;\n        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\");\n        this.eventOptions = descriptor.eventOptions || {};\n        this.identifier = descriptor.identifier || error(\"missing identifier\");\n        this.methodName = descriptor.methodName || error(\"missing method name\");\n        this.keyFilter = descriptor.keyFilter || \"\";\n        this.schema = schema;\n    }\n    static forToken(token, schema) {\n        return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);\n    }\n    toString() {\n        const eventFilter = this.keyFilter ? `.${this.keyFilter}` : \"\";\n        const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : \"\";\n        return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;\n    }\n    shouldIgnoreKeyboardEvent(event) {\n        if (!this.keyFilter) {\n            return false;\n        }\n        const filters = this.keyFilter.split(\"+\");\n        if (this.keyFilterDissatisfied(event, filters)) {\n            return true;\n        }\n        const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];\n        if (!standardFilter) {\n            return false;\n        }\n        if (!hasProperty(this.keyMappings, standardFilter)) {\n            error(`contains unknown key filter: ${this.keyFilter}`);\n        }\n        return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();\n    }\n    shouldIgnoreMouseEvent(event) {\n        if (!this.keyFilter) {\n            return false;\n        }\n        const filters = [this.keyFilter];\n        if (this.keyFilterDissatisfied(event, filters)) {\n            return true;\n        }\n        return false;\n    }\n    get params() {\n        const params = {};\n        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, \"i\");\n        for (const { name, value } of Array.from(this.element.attributes)) {\n            const match = name.match(pattern);\n            const key = match && match[1];\n            if (key) {\n                params[camelize(key)] = typecast(value);\n            }\n        }\n        return params;\n    }\n    get eventTargetName() {\n        return stringifyEventTarget(this.eventTarget);\n    }\n    get keyMappings() {\n        return this.schema.keyMappings;\n    }\n    keyFilterDissatisfied(event, filters) {\n        const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));\n        return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;\n    }\n}\nconst defaultEventNames = {\n    a: () => \"click\",\n    button: () => \"click\",\n    form: () => \"submit\",\n    details: () => \"toggle\",\n    input: (e) => (e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\"),\n    select: () => \"change\",\n    textarea: () => \"input\",\n};\nfunction getDefaultEventNameForElement(element) {\n    const tagName = element.tagName.toLowerCase();\n    if (tagName in defaultEventNames) {\n        return defaultEventNames[tagName](element);\n    }\n}\nfunction error(message) {\n    throw new Error(message);\n}\nfunction typecast(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch (o_O) {\n        return value;\n    }\n}\n\nclass Binding {\n    constructor(context, action) {\n        this.context = context;\n        this.action = action;\n    }\n    get index() {\n        return this.action.index;\n    }\n    get eventTarget() {\n        return this.action.eventTarget;\n    }\n    get eventOptions() {\n        return this.action.eventOptions;\n    }\n    get identifier() {\n        return this.context.identifier;\n    }\n    handleEvent(event) {\n        const actionEvent = this.prepareActionEvent(event);\n        if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {\n            this.invokeWithEvent(actionEvent);\n        }\n    }\n    get eventName() {\n        return this.action.eventName;\n    }\n    get method() {\n        const method = this.controller[this.methodName];\n        if (typeof method == \"function\") {\n            return method;\n        }\n        throw new Error(`Action \"${this.action}\" references undefined method \"${this.methodName}\"`);\n    }\n    applyEventModifiers(event) {\n        const { element } = this.action;\n        const { actionDescriptorFilters } = this.context.application;\n        const { controller } = this.context;\n        let passes = true;\n        for (const [name, value] of Object.entries(this.eventOptions)) {\n            if (name in actionDescriptorFilters) {\n                const filter = actionDescriptorFilters[name];\n                passes = passes && filter({ name, value, event, element, controller });\n            }\n            else {\n                continue;\n            }\n        }\n        return passes;\n    }\n    prepareActionEvent(event) {\n        return Object.assign(event, { params: this.action.params });\n    }\n    invokeWithEvent(event) {\n        const { target, currentTarget } = event;\n        try {\n            this.method.call(this.controller, event);\n            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });\n        }\n        catch (error) {\n            const { identifier, controller, element, index } = this;\n            const detail = { identifier, controller, element, index, event };\n            this.context.handleError(error, `invoking action \"${this.action}\"`, detail);\n        }\n    }\n    willBeInvokedByEvent(event) {\n        const eventTarget = event.target;\n        if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {\n            return false;\n        }\n        if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {\n            return false;\n        }\n        if (this.element === eventTarget) {\n            return true;\n        }\n        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n            return this.scope.containsElement(eventTarget);\n        }\n        else {\n            return this.scope.containsElement(this.action.element);\n        }\n    }\n    get controller() {\n        return this.context.controller;\n    }\n    get methodName() {\n        return this.action.methodName;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n}\n\nclass ElementObserver {\n    constructor(element, delegate) {\n        this.mutationObserverInit = { attributes: true, childList: true, subtree: true };\n        this.element = element;\n        this.started = false;\n        this.delegate = delegate;\n        this.elements = new Set();\n        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, this.mutationObserverInit);\n            this.refresh();\n        }\n    }\n    pause(callback) {\n        if (this.started) {\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n        callback();\n        if (!this.started) {\n            this.mutationObserver.observe(this.element, this.mutationObserverInit);\n            this.started = true;\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    }\n    refresh() {\n        if (this.started) {\n            const matches = new Set(this.matchElementsInTree());\n            for (const element of Array.from(this.elements)) {\n                if (!matches.has(element)) {\n                    this.removeElement(element);\n                }\n            }\n            for (const element of Array.from(matches)) {\n                this.addElement(element);\n            }\n        }\n    }\n    processMutations(mutations) {\n        if (this.started) {\n            for (const mutation of mutations) {\n                this.processMutation(mutation);\n            }\n        }\n    }\n    processMutation(mutation) {\n        if (mutation.type == \"attributes\") {\n            this.processAttributeChange(mutation.target, mutation.attributeName);\n        }\n        else if (mutation.type == \"childList\") {\n            this.processRemovedNodes(mutation.removedNodes);\n            this.processAddedNodes(mutation.addedNodes);\n        }\n    }\n    processAttributeChange(element, attributeName) {\n        if (this.elements.has(element)) {\n            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n                this.delegate.elementAttributeChanged(element, attributeName);\n            }\n            else {\n                this.removeElement(element);\n            }\n        }\n        else if (this.matchElement(element)) {\n            this.addElement(element);\n        }\n    }\n    processRemovedNodes(nodes) {\n        for (const node of Array.from(nodes)) {\n            const element = this.elementFromNode(node);\n            if (element) {\n                this.processTree(element, this.removeElement);\n            }\n        }\n    }\n    processAddedNodes(nodes) {\n        for (const node of Array.from(nodes)) {\n            const element = this.elementFromNode(node);\n            if (element && this.elementIsActive(element)) {\n                this.processTree(element, this.addElement);\n            }\n        }\n    }\n    matchElement(element) {\n        return this.delegate.matchElement(element);\n    }\n    matchElementsInTree(tree = this.element) {\n        return this.delegate.matchElementsInTree(tree);\n    }\n    processTree(tree, processor) {\n        for (const element of this.matchElementsInTree(tree)) {\n            processor.call(this, element);\n        }\n    }\n    elementFromNode(node) {\n        if (node.nodeType == Node.ELEMENT_NODE) {\n            return node;\n        }\n    }\n    elementIsActive(element) {\n        if (element.isConnected != this.element.isConnected) {\n            return false;\n        }\n        else {\n            return this.element.contains(element);\n        }\n    }\n    addElement(element) {\n        if (!this.elements.has(element)) {\n            if (this.elementIsActive(element)) {\n                this.elements.add(element);\n                if (this.delegate.elementMatched) {\n                    this.delegate.elementMatched(element);\n                }\n            }\n        }\n    }\n    removeElement(element) {\n        if (this.elements.has(element)) {\n            this.elements.delete(element);\n            if (this.delegate.elementUnmatched) {\n                this.delegate.elementUnmatched(element);\n            }\n        }\n    }\n}\n\nclass AttributeObserver {\n    constructor(element, attributeName, delegate) {\n        this.attributeName = attributeName;\n        this.delegate = delegate;\n        this.elementObserver = new ElementObserver(element, this);\n    }\n    get element() {\n        return this.elementObserver.element;\n    }\n    get selector() {\n        return `[${this.attributeName}]`;\n    }\n    start() {\n        this.elementObserver.start();\n    }\n    pause(callback) {\n        this.elementObserver.pause(callback);\n    }\n    stop() {\n        this.elementObserver.stop();\n    }\n    refresh() {\n        this.elementObserver.refresh();\n    }\n    get started() {\n        return this.elementObserver.started;\n    }\n    matchElement(element) {\n        return element.hasAttribute(this.attributeName);\n    }\n    matchElementsInTree(tree) {\n        const match = this.matchElement(tree) ? [tree] : [];\n        const matches = Array.from(tree.querySelectorAll(this.selector));\n        return match.concat(matches);\n    }\n    elementMatched(element) {\n        if (this.delegate.elementMatchedAttribute) {\n            this.delegate.elementMatchedAttribute(element, this.attributeName);\n        }\n    }\n    elementUnmatched(element) {\n        if (this.delegate.elementUnmatchedAttribute) {\n            this.delegate.elementUnmatchedAttribute(element, this.attributeName);\n        }\n    }\n    elementAttributeChanged(element, attributeName) {\n        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n            this.delegate.elementAttributeValueChanged(element, attributeName);\n        }\n    }\n}\n\nfunction add(map, key, value) {\n    fetch(map, key).add(value);\n}\nfunction del(map, key, value) {\n    fetch(map, key).delete(value);\n    prune(map, key);\n}\nfunction fetch(map, key) {\n    let values = map.get(key);\n    if (!values) {\n        values = new Set();\n        map.set(key, values);\n    }\n    return values;\n}\nfunction prune(map, key) {\n    const values = map.get(key);\n    if (values != null && values.size == 0) {\n        map.delete(key);\n    }\n}\n\nclass Multimap {\n    constructor() {\n        this.valuesByKey = new Map();\n    }\n    get keys() {\n        return Array.from(this.valuesByKey.keys());\n    }\n    get values() {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.reduce((values, set) => values.concat(Array.from(set)), []);\n    }\n    get size() {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.reduce((size, set) => size + set.size, 0);\n    }\n    add(key, value) {\n        add(this.valuesByKey, key, value);\n    }\n    delete(key, value) {\n        del(this.valuesByKey, key, value);\n    }\n    has(key, value) {\n        const values = this.valuesByKey.get(key);\n        return values != null && values.has(value);\n    }\n    hasKey(key) {\n        return this.valuesByKey.has(key);\n    }\n    hasValue(value) {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.some((set) => set.has(value));\n    }\n    getValuesForKey(key) {\n        const values = this.valuesByKey.get(key);\n        return values ? Array.from(values) : [];\n    }\n    getKeysForValue(value) {\n        return Array.from(this.valuesByKey)\n            .filter(([_key, values]) => values.has(value))\n            .map(([key, _values]) => key);\n    }\n}\n\nclass IndexedMultimap extends Multimap {\n    constructor() {\n        super();\n        this.keysByValue = new Map();\n    }\n    get values() {\n        return Array.from(this.keysByValue.keys());\n    }\n    add(key, value) {\n        super.add(key, value);\n        add(this.keysByValue, value, key);\n    }\n    delete(key, value) {\n        super.delete(key, value);\n        del(this.keysByValue, value, key);\n    }\n    hasValue(value) {\n        return this.keysByValue.has(value);\n    }\n    getKeysForValue(value) {\n        const set = this.keysByValue.get(value);\n        return set ? Array.from(set) : [];\n    }\n}\n\nclass SelectorObserver {\n    constructor(element, selector, delegate, details) {\n        this._selector = selector;\n        this.details = details;\n        this.elementObserver = new ElementObserver(element, this);\n        this.delegate = delegate;\n        this.matchesByElement = new Multimap();\n    }\n    get started() {\n        return this.elementObserver.started;\n    }\n    get selector() {\n        return this._selector;\n    }\n    set selector(selector) {\n        this._selector = selector;\n        this.refresh();\n    }\n    start() {\n        this.elementObserver.start();\n    }\n    pause(callback) {\n        this.elementObserver.pause(callback);\n    }\n    stop() {\n        this.elementObserver.stop();\n    }\n    refresh() {\n        this.elementObserver.refresh();\n    }\n    get element() {\n        return this.elementObserver.element;\n    }\n    matchElement(element) {\n        const { selector } = this;\n        if (selector) {\n            const matches = element.matches(selector);\n            if (this.delegate.selectorMatchElement) {\n                return matches && this.delegate.selectorMatchElement(element, this.details);\n            }\n            return matches;\n        }\n        else {\n            return false;\n        }\n    }\n    matchElementsInTree(tree) {\n        const { selector } = this;\n        if (selector) {\n            const match = this.matchElement(tree) ? [tree] : [];\n            const matches = Array.from(tree.querySelectorAll(selector)).filter((match) => this.matchElement(match));\n            return match.concat(matches);\n        }\n        else {\n            return [];\n        }\n    }\n    elementMatched(element) {\n        const { selector } = this;\n        if (selector) {\n            this.selectorMatched(element, selector);\n        }\n    }\n    elementUnmatched(element) {\n        const selectors = this.matchesByElement.getKeysForValue(element);\n        for (const selector of selectors) {\n            this.selectorUnmatched(element, selector);\n        }\n    }\n    elementAttributeChanged(element, _attributeName) {\n        const { selector } = this;\n        if (selector) {\n            const matches = this.matchElement(element);\n            const matchedBefore = this.matchesByElement.has(selector, element);\n            if (matches && !matchedBefore) {\n                this.selectorMatched(element, selector);\n            }\n            else if (!matches && matchedBefore) {\n                this.selectorUnmatched(element, selector);\n            }\n        }\n    }\n    selectorMatched(element, selector) {\n        this.delegate.selectorMatched(element, selector, this.details);\n        this.matchesByElement.add(selector, element);\n    }\n    selectorUnmatched(element, selector) {\n        this.delegate.selectorUnmatched(element, selector, this.details);\n        this.matchesByElement.delete(selector, element);\n    }\n}\n\nclass StringMapObserver {\n    constructor(element, delegate) {\n        this.element = element;\n        this.delegate = delegate;\n        this.started = false;\n        this.stringMap = new Map();\n        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });\n            this.refresh();\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    }\n    refresh() {\n        if (this.started) {\n            for (const attributeName of this.knownAttributeNames) {\n                this.refreshAttribute(attributeName, null);\n            }\n        }\n    }\n    processMutations(mutations) {\n        if (this.started) {\n            for (const mutation of mutations) {\n                this.processMutation(mutation);\n            }\n        }\n    }\n    processMutation(mutation) {\n        const attributeName = mutation.attributeName;\n        if (attributeName) {\n            this.refreshAttribute(attributeName, mutation.oldValue);\n        }\n    }\n    refreshAttribute(attributeName, oldValue) {\n        const key = this.delegate.getStringMapKeyForAttribute(attributeName);\n        if (key != null) {\n            if (!this.stringMap.has(attributeName)) {\n                this.stringMapKeyAdded(key, attributeName);\n            }\n            const value = this.element.getAttribute(attributeName);\n            if (this.stringMap.get(attributeName) != value) {\n                this.stringMapValueChanged(value, key, oldValue);\n            }\n            if (value == null) {\n                const oldValue = this.stringMap.get(attributeName);\n                this.stringMap.delete(attributeName);\n                if (oldValue)\n                    this.stringMapKeyRemoved(key, attributeName, oldValue);\n            }\n            else {\n                this.stringMap.set(attributeName, value);\n            }\n        }\n    }\n    stringMapKeyAdded(key, attributeName) {\n        if (this.delegate.stringMapKeyAdded) {\n            this.delegate.stringMapKeyAdded(key, attributeName);\n        }\n    }\n    stringMapValueChanged(value, key, oldValue) {\n        if (this.delegate.stringMapValueChanged) {\n            this.delegate.stringMapValueChanged(value, key, oldValue);\n        }\n    }\n    stringMapKeyRemoved(key, attributeName, oldValue) {\n        if (this.delegate.stringMapKeyRemoved) {\n            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);\n        }\n    }\n    get knownAttributeNames() {\n        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));\n    }\n    get currentAttributeNames() {\n        return Array.from(this.element.attributes).map((attribute) => attribute.name);\n    }\n    get recordedAttributeNames() {\n        return Array.from(this.stringMap.keys());\n    }\n}\n\nclass TokenListObserver {\n    constructor(element, attributeName, delegate) {\n        this.attributeObserver = new AttributeObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.tokensByElement = new Multimap();\n    }\n    get started() {\n        return this.attributeObserver.started;\n    }\n    start() {\n        this.attributeObserver.start();\n    }\n    pause(callback) {\n        this.attributeObserver.pause(callback);\n    }\n    stop() {\n        this.attributeObserver.stop();\n    }\n    refresh() {\n        this.attributeObserver.refresh();\n    }\n    get element() {\n        return this.attributeObserver.element;\n    }\n    get attributeName() {\n        return this.attributeObserver.attributeName;\n    }\n    elementMatchedAttribute(element) {\n        this.tokensMatched(this.readTokensForElement(element));\n    }\n    elementAttributeValueChanged(element) {\n        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);\n        this.tokensUnmatched(unmatchedTokens);\n        this.tokensMatched(matchedTokens);\n    }\n    elementUnmatchedAttribute(element) {\n        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));\n    }\n    tokensMatched(tokens) {\n        tokens.forEach((token) => this.tokenMatched(token));\n    }\n    tokensUnmatched(tokens) {\n        tokens.forEach((token) => this.tokenUnmatched(token));\n    }\n    tokenMatched(token) {\n        this.delegate.tokenMatched(token);\n        this.tokensByElement.add(token.element, token);\n    }\n    tokenUnmatched(token) {\n        this.delegate.tokenUnmatched(token);\n        this.tokensByElement.delete(token.element, token);\n    }\n    refreshTokensForElement(element) {\n        const previousTokens = this.tokensByElement.getValuesForKey(element);\n        const currentTokens = this.readTokensForElement(element);\n        const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));\n        if (firstDifferingIndex == -1) {\n            return [[], []];\n        }\n        else {\n            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];\n        }\n    }\n    readTokensForElement(element) {\n        const attributeName = this.attributeName;\n        const tokenString = element.getAttribute(attributeName) || \"\";\n        return parseTokenString(tokenString, element, attributeName);\n    }\n}\nfunction parseTokenString(tokenString, element, attributeName) {\n    return tokenString\n        .trim()\n        .split(/\\s+/)\n        .filter((content) => content.length)\n        .map((content, index) => ({ element, attributeName, content, index }));\n}\nfunction zip(left, right) {\n    const length = Math.max(left.length, right.length);\n    return Array.from({ length }, (_, index) => [left[index], right[index]]);\n}\nfunction tokensAreEqual(left, right) {\n    return left && right && left.index == right.index && left.content == right.content;\n}\n\nclass ValueListObserver {\n    constructor(element, attributeName, delegate) {\n        this.tokenListObserver = new TokenListObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.parseResultsByToken = new WeakMap();\n        this.valuesByTokenByElement = new WeakMap();\n    }\n    get started() {\n        return this.tokenListObserver.started;\n    }\n    start() {\n        this.tokenListObserver.start();\n    }\n    stop() {\n        this.tokenListObserver.stop();\n    }\n    refresh() {\n        this.tokenListObserver.refresh();\n    }\n    get element() {\n        return this.tokenListObserver.element;\n    }\n    get attributeName() {\n        return this.tokenListObserver.attributeName;\n    }\n    tokenMatched(token) {\n        const { element } = token;\n        const { value } = this.fetchParseResultForToken(token);\n        if (value) {\n            this.fetchValuesByTokenForElement(element).set(token, value);\n            this.delegate.elementMatchedValue(element, value);\n        }\n    }\n    tokenUnmatched(token) {\n        const { element } = token;\n        const { value } = this.fetchParseResultForToken(token);\n        if (value) {\n            this.fetchValuesByTokenForElement(element).delete(token);\n            this.delegate.elementUnmatchedValue(element, value);\n        }\n    }\n    fetchParseResultForToken(token) {\n        let parseResult = this.parseResultsByToken.get(token);\n        if (!parseResult) {\n            parseResult = this.parseToken(token);\n            this.parseResultsByToken.set(token, parseResult);\n        }\n        return parseResult;\n    }\n    fetchValuesByTokenForElement(element) {\n        let valuesByToken = this.valuesByTokenByElement.get(element);\n        if (!valuesByToken) {\n            valuesByToken = new Map();\n            this.valuesByTokenByElement.set(element, valuesByToken);\n        }\n        return valuesByToken;\n    }\n    parseToken(token) {\n        try {\n            const value = this.delegate.parseValueForToken(token);\n            return { value };\n        }\n        catch (error) {\n            return { error };\n        }\n    }\n}\n\nclass BindingObserver {\n    constructor(context, delegate) {\n        this.context = context;\n        this.delegate = delegate;\n        this.bindingsByAction = new Map();\n    }\n    start() {\n        if (!this.valueListObserver) {\n            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);\n            this.valueListObserver.start();\n        }\n    }\n    stop() {\n        if (this.valueListObserver) {\n            this.valueListObserver.stop();\n            delete this.valueListObserver;\n            this.disconnectAllActions();\n        }\n    }\n    get element() {\n        return this.context.element;\n    }\n    get identifier() {\n        return this.context.identifier;\n    }\n    get actionAttribute() {\n        return this.schema.actionAttribute;\n    }\n    get schema() {\n        return this.context.schema;\n    }\n    get bindings() {\n        return Array.from(this.bindingsByAction.values());\n    }\n    connectAction(action) {\n        const binding = new Binding(this.context, action);\n        this.bindingsByAction.set(action, binding);\n        this.delegate.bindingConnected(binding);\n    }\n    disconnectAction(action) {\n        const binding = this.bindingsByAction.get(action);\n        if (binding) {\n            this.bindingsByAction.delete(action);\n            this.delegate.bindingDisconnected(binding);\n        }\n    }\n    disconnectAllActions() {\n        this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));\n        this.bindingsByAction.clear();\n    }\n    parseValueForToken(token) {\n        const action = Action.forToken(token, this.schema);\n        if (action.identifier == this.identifier) {\n            return action;\n        }\n    }\n    elementMatchedValue(element, action) {\n        this.connectAction(action);\n    }\n    elementUnmatchedValue(element, action) {\n        this.disconnectAction(action);\n    }\n}\n\nclass ValueObserver {\n    constructor(context, receiver) {\n        this.context = context;\n        this.receiver = receiver;\n        this.stringMapObserver = new StringMapObserver(this.element, this);\n        this.valueDescriptorMap = this.controller.valueDescriptorMap;\n    }\n    start() {\n        this.stringMapObserver.start();\n        this.invokeChangedCallbacksForDefaultValues();\n    }\n    stop() {\n        this.stringMapObserver.stop();\n    }\n    get element() {\n        return this.context.element;\n    }\n    get controller() {\n        return this.context.controller;\n    }\n    getStringMapKeyForAttribute(attributeName) {\n        if (attributeName in this.valueDescriptorMap) {\n            return this.valueDescriptorMap[attributeName].name;\n        }\n    }\n    stringMapKeyAdded(key, attributeName) {\n        const descriptor = this.valueDescriptorMap[attributeName];\n        if (!this.hasValue(key)) {\n            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));\n        }\n    }\n    stringMapValueChanged(value, name, oldValue) {\n        const descriptor = this.valueDescriptorNameMap[name];\n        if (value === null)\n            return;\n        if (oldValue === null) {\n            oldValue = descriptor.writer(descriptor.defaultValue);\n        }\n        this.invokeChangedCallback(name, value, oldValue);\n    }\n    stringMapKeyRemoved(key, attributeName, oldValue) {\n        const descriptor = this.valueDescriptorNameMap[key];\n        if (this.hasValue(key)) {\n            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);\n        }\n        else {\n            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);\n        }\n    }\n    invokeChangedCallbacksForDefaultValues() {\n        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {\n            if (defaultValue != undefined && !this.controller.data.has(key)) {\n                this.invokeChangedCallback(name, writer(defaultValue), undefined);\n            }\n        }\n    }\n    invokeChangedCallback(name, rawValue, rawOldValue) {\n        const changedMethodName = `${name}Changed`;\n        const changedMethod = this.receiver[changedMethodName];\n        if (typeof changedMethod == \"function\") {\n            const descriptor = this.valueDescriptorNameMap[name];\n            try {\n                const value = descriptor.reader(rawValue);\n                let oldValue = rawOldValue;\n                if (rawOldValue) {\n                    oldValue = descriptor.reader(rawOldValue);\n                }\n                changedMethod.call(this.receiver, value, oldValue);\n            }\n            catch (error) {\n                if (error instanceof TypeError) {\n                    error.message = `Stimulus Value \"${this.context.identifier}.${descriptor.name}\" - ${error.message}`;\n                }\n                throw error;\n            }\n        }\n    }\n    get valueDescriptors() {\n        const { valueDescriptorMap } = this;\n        return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);\n    }\n    get valueDescriptorNameMap() {\n        const descriptors = {};\n        Object.keys(this.valueDescriptorMap).forEach((key) => {\n            const descriptor = this.valueDescriptorMap[key];\n            descriptors[descriptor.name] = descriptor;\n        });\n        return descriptors;\n    }\n    hasValue(attributeName) {\n        const descriptor = this.valueDescriptorNameMap[attributeName];\n        const hasMethodName = `has${capitalize(descriptor.name)}`;\n        return this.receiver[hasMethodName];\n    }\n}\n\nclass TargetObserver {\n    constructor(context, delegate) {\n        this.context = context;\n        this.delegate = delegate;\n        this.targetsByName = new Multimap();\n    }\n    start() {\n        if (!this.tokenListObserver) {\n            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);\n            this.tokenListObserver.start();\n        }\n    }\n    stop() {\n        if (this.tokenListObserver) {\n            this.disconnectAllTargets();\n            this.tokenListObserver.stop();\n            delete this.tokenListObserver;\n        }\n    }\n    tokenMatched({ element, content: name }) {\n        if (this.scope.containsElement(element)) {\n            this.connectTarget(element, name);\n        }\n    }\n    tokenUnmatched({ element, content: name }) {\n        this.disconnectTarget(element, name);\n    }\n    connectTarget(element, name) {\n        var _a;\n        if (!this.targetsByName.has(name, element)) {\n            this.targetsByName.add(name, element);\n            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));\n        }\n    }\n    disconnectTarget(element, name) {\n        var _a;\n        if (this.targetsByName.has(name, element)) {\n            this.targetsByName.delete(name, element);\n            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));\n        }\n    }\n    disconnectAllTargets() {\n        for (const name of this.targetsByName.keys) {\n            for (const element of this.targetsByName.getValuesForKey(name)) {\n                this.disconnectTarget(element, name);\n            }\n        }\n    }\n    get attributeName() {\n        return `data-${this.context.identifier}-target`;\n    }\n    get element() {\n        return this.context.element;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n}\n\nfunction readInheritableStaticArrayValues(constructor, propertyName) {\n    const ancestors = getAncestorsForConstructor(constructor);\n    return Array.from(ancestors.reduce((values, constructor) => {\n        getOwnStaticArrayValues(constructor, propertyName).forEach((name) => values.add(name));\n        return values;\n    }, new Set()));\n}\nfunction readInheritableStaticObjectPairs(constructor, propertyName) {\n    const ancestors = getAncestorsForConstructor(constructor);\n    return ancestors.reduce((pairs, constructor) => {\n        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));\n        return pairs;\n    }, []);\n}\nfunction getAncestorsForConstructor(constructor) {\n    const ancestors = [];\n    while (constructor) {\n        ancestors.push(constructor);\n        constructor = Object.getPrototypeOf(constructor);\n    }\n    return ancestors.reverse();\n}\nfunction getOwnStaticArrayValues(constructor, propertyName) {\n    const definition = constructor[propertyName];\n    return Array.isArray(definition) ? definition : [];\n}\nfunction getOwnStaticObjectPairs(constructor, propertyName) {\n    const definition = constructor[propertyName];\n    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];\n}\n\nclass OutletObserver {\n    constructor(context, delegate) {\n        this.started = false;\n        this.context = context;\n        this.delegate = delegate;\n        this.outletsByName = new Multimap();\n        this.outletElementsByName = new Multimap();\n        this.selectorObserverMap = new Map();\n        this.attributeObserverMap = new Map();\n    }\n    start() {\n        if (!this.started) {\n            this.outletDefinitions.forEach((outletName) => {\n                this.setupSelectorObserverForOutlet(outletName);\n                this.setupAttributeObserverForOutlet(outletName);\n            });\n            this.started = true;\n            this.dependentContexts.forEach((context) => context.refresh());\n        }\n    }\n    refresh() {\n        this.selectorObserverMap.forEach((observer) => observer.refresh());\n        this.attributeObserverMap.forEach((observer) => observer.refresh());\n    }\n    stop() {\n        if (this.started) {\n            this.started = false;\n            this.disconnectAllOutlets();\n            this.stopSelectorObservers();\n            this.stopAttributeObservers();\n        }\n    }\n    stopSelectorObservers() {\n        if (this.selectorObserverMap.size > 0) {\n            this.selectorObserverMap.forEach((observer) => observer.stop());\n            this.selectorObserverMap.clear();\n        }\n    }\n    stopAttributeObservers() {\n        if (this.attributeObserverMap.size > 0) {\n            this.attributeObserverMap.forEach((observer) => observer.stop());\n            this.attributeObserverMap.clear();\n        }\n    }\n    selectorMatched(element, _selector, { outletName }) {\n        const outlet = this.getOutlet(element, outletName);\n        if (outlet) {\n            this.connectOutlet(outlet, element, outletName);\n        }\n    }\n    selectorUnmatched(element, _selector, { outletName }) {\n        const outlet = this.getOutletFromMap(element, outletName);\n        if (outlet) {\n            this.disconnectOutlet(outlet, element, outletName);\n        }\n    }\n    selectorMatchElement(element, { outletName }) {\n        const selector = this.selector(outletName);\n        const hasOutlet = this.hasOutlet(element, outletName);\n        const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);\n        if (selector) {\n            return hasOutlet && hasOutletController && element.matches(selector);\n        }\n        else {\n            return false;\n        }\n    }\n    elementMatchedAttribute(_element, attributeName) {\n        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n        if (outletName) {\n            this.updateSelectorObserverForOutlet(outletName);\n        }\n    }\n    elementAttributeValueChanged(_element, attributeName) {\n        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n        if (outletName) {\n            this.updateSelectorObserverForOutlet(outletName);\n        }\n    }\n    elementUnmatchedAttribute(_element, attributeName) {\n        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);\n        if (outletName) {\n            this.updateSelectorObserverForOutlet(outletName);\n        }\n    }\n    connectOutlet(outlet, element, outletName) {\n        var _a;\n        if (!this.outletElementsByName.has(outletName, element)) {\n            this.outletsByName.add(outletName, outlet);\n            this.outletElementsByName.add(outletName, element);\n            (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));\n        }\n    }\n    disconnectOutlet(outlet, element, outletName) {\n        var _a;\n        if (this.outletElementsByName.has(outletName, element)) {\n            this.outletsByName.delete(outletName, outlet);\n            this.outletElementsByName.delete(outletName, element);\n            (_a = this.selectorObserverMap\n                .get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));\n        }\n    }\n    disconnectAllOutlets() {\n        for (const outletName of this.outletElementsByName.keys) {\n            for (const element of this.outletElementsByName.getValuesForKey(outletName)) {\n                for (const outlet of this.outletsByName.getValuesForKey(outletName)) {\n                    this.disconnectOutlet(outlet, element, outletName);\n                }\n            }\n        }\n    }\n    updateSelectorObserverForOutlet(outletName) {\n        const observer = this.selectorObserverMap.get(outletName);\n        if (observer) {\n            observer.selector = this.selector(outletName);\n        }\n    }\n    setupSelectorObserverForOutlet(outletName) {\n        const selector = this.selector(outletName);\n        const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });\n        this.selectorObserverMap.set(outletName, selectorObserver);\n        selectorObserver.start();\n    }\n    setupAttributeObserverForOutlet(outletName) {\n        const attributeName = this.attributeNameForOutletName(outletName);\n        const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);\n        this.attributeObserverMap.set(outletName, attributeObserver);\n        attributeObserver.start();\n    }\n    selector(outletName) {\n        return this.scope.outlets.getSelectorForOutletName(outletName);\n    }\n    attributeNameForOutletName(outletName) {\n        return this.scope.schema.outletAttributeForScope(this.identifier, outletName);\n    }\n    getOutletNameFromOutletAttributeName(attributeName) {\n        return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);\n    }\n    get outletDependencies() {\n        const dependencies = new Multimap();\n        this.router.modules.forEach((module) => {\n            const constructor = module.definition.controllerConstructor;\n            const outlets = readInheritableStaticArrayValues(constructor, \"outlets\");\n            outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));\n        });\n        return dependencies;\n    }\n    get outletDefinitions() {\n        return this.outletDependencies.getKeysForValue(this.identifier);\n    }\n    get dependentControllerIdentifiers() {\n        return this.outletDependencies.getValuesForKey(this.identifier);\n    }\n    get dependentContexts() {\n        const identifiers = this.dependentControllerIdentifiers;\n        return this.router.contexts.filter((context) => identifiers.includes(context.identifier));\n    }\n    hasOutlet(element, outletName) {\n        return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);\n    }\n    getOutlet(element, outletName) {\n        return this.application.getControllerForElementAndIdentifier(element, outletName);\n    }\n    getOutletFromMap(element, outletName) {\n        return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);\n    }\n    get scope() {\n        return this.context.scope;\n    }\n    get schema() {\n        return this.context.schema;\n    }\n    get identifier() {\n        return this.context.identifier;\n    }\n    get application() {\n        return this.context.application;\n    }\n    get router() {\n        return this.application.router;\n    }\n}\n\nclass Context {\n    constructor(module, scope) {\n        this.logDebugActivity = (functionName, detail = {}) => {\n            const { identifier, controller, element } = this;\n            detail = Object.assign({ identifier, controller, element }, detail);\n            this.application.logDebugActivity(this.identifier, functionName, detail);\n        };\n        this.module = module;\n        this.scope = scope;\n        this.controller = new module.controllerConstructor(this);\n        this.bindingObserver = new BindingObserver(this, this.dispatcher);\n        this.valueObserver = new ValueObserver(this, this.controller);\n        this.targetObserver = new TargetObserver(this, this);\n        this.outletObserver = new OutletObserver(this, this);\n        try {\n            this.controller.initialize();\n            this.logDebugActivity(\"initialize\");\n        }\n        catch (error) {\n            this.handleError(error, \"initializing controller\");\n        }\n    }\n    connect() {\n        this.bindingObserver.start();\n        this.valueObserver.start();\n        this.targetObserver.start();\n        this.outletObserver.start();\n        try {\n            this.controller.connect();\n            this.logDebugActivity(\"connect\");\n        }\n        catch (error) {\n            this.handleError(error, \"connecting controller\");\n        }\n    }\n    refresh() {\n        this.outletObserver.refresh();\n    }\n    disconnect() {\n        try {\n            this.controller.disconnect();\n            this.logDebugActivity(\"disconnect\");\n        }\n        catch (error) {\n            this.handleError(error, \"disconnecting controller\");\n        }\n        this.outletObserver.stop();\n        this.targetObserver.stop();\n        this.valueObserver.stop();\n        this.bindingObserver.stop();\n    }\n    get application() {\n        return this.module.application;\n    }\n    get identifier() {\n        return this.module.identifier;\n    }\n    get schema() {\n        return this.application.schema;\n    }\n    get dispatcher() {\n        return this.application.dispatcher;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get parentElement() {\n        return this.element.parentElement;\n    }\n    handleError(error, message, detail = {}) {\n        const { identifier, controller, element } = this;\n        detail = Object.assign({ identifier, controller, element }, detail);\n        this.application.handleError(error, `Error ${message}`, detail);\n    }\n    targetConnected(element, name) {\n        this.invokeControllerMethod(`${name}TargetConnected`, element);\n    }\n    targetDisconnected(element, name) {\n        this.invokeControllerMethod(`${name}TargetDisconnected`, element);\n    }\n    outletConnected(outlet, element, name) {\n        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);\n    }\n    outletDisconnected(outlet, element, name) {\n        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);\n    }\n    invokeControllerMethod(methodName, ...args) {\n        const controller = this.controller;\n        if (typeof controller[methodName] == \"function\") {\n            controller[methodName](...args);\n        }\n    }\n}\n\nfunction bless(constructor) {\n    return shadow(constructor, getBlessedProperties(constructor));\n}\nfunction shadow(constructor, properties) {\n    const shadowConstructor = extend(constructor);\n    const shadowProperties = getShadowProperties(constructor.prototype, properties);\n    Object.defineProperties(shadowConstructor.prototype, shadowProperties);\n    return shadowConstructor;\n}\nfunction getBlessedProperties(constructor) {\n    const blessings = readInheritableStaticArrayValues(constructor, \"blessings\");\n    return blessings.reduce((blessedProperties, blessing) => {\n        const properties = blessing(constructor);\n        for (const key in properties) {\n            const descriptor = blessedProperties[key] || {};\n            blessedProperties[key] = Object.assign(descriptor, properties[key]);\n        }\n        return blessedProperties;\n    }, {});\n}\nfunction getShadowProperties(prototype, properties) {\n    return getOwnKeys(properties).reduce((shadowProperties, key) => {\n        const descriptor = getShadowedDescriptor(prototype, properties, key);\n        if (descriptor) {\n            Object.assign(shadowProperties, { [key]: descriptor });\n        }\n        return shadowProperties;\n    }, {});\n}\nfunction getShadowedDescriptor(prototype, properties, key) {\n    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    const shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor;\n    if (!shadowedByValue) {\n        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;\n        if (shadowingDescriptor) {\n            descriptor.get = shadowingDescriptor.get || descriptor.get;\n            descriptor.set = shadowingDescriptor.set || descriptor.set;\n        }\n        return descriptor;\n    }\n}\nconst getOwnKeys = (() => {\n    if (typeof Object.getOwnPropertySymbols == \"function\") {\n        return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];\n    }\n    else {\n        return Object.getOwnPropertyNames;\n    }\n})();\nconst extend = (() => {\n    function extendWithReflect(constructor) {\n        function extended() {\n            return Reflect.construct(constructor, arguments, new.target);\n        }\n        extended.prototype = Object.create(constructor.prototype, {\n            constructor: { value: extended },\n        });\n        Reflect.setPrototypeOf(extended, constructor);\n        return extended;\n    }\n    function testReflectExtension() {\n        const a = function () {\n            this.a.call(this);\n        };\n        const b = extendWithReflect(a);\n        b.prototype.a = function () { };\n        return new b();\n    }\n    try {\n        testReflectExtension();\n        return extendWithReflect;\n    }\n    catch (error) {\n        return (constructor) => class extended extends constructor {\n        };\n    }\n})();\n\nfunction blessDefinition(definition) {\n    return {\n        identifier: definition.identifier,\n        controllerConstructor: bless(definition.controllerConstructor),\n    };\n}\n\nclass Module {\n    constructor(application, definition) {\n        this.application = application;\n        this.definition = blessDefinition(definition);\n        this.contextsByScope = new WeakMap();\n        this.connectedContexts = new Set();\n    }\n    get identifier() {\n        return this.definition.identifier;\n    }\n    get controllerConstructor() {\n        return this.definition.controllerConstructor;\n    }\n    get contexts() {\n        return Array.from(this.connectedContexts);\n    }\n    connectContextForScope(scope) {\n        const context = this.fetchContextForScope(scope);\n        this.connectedContexts.add(context);\n        context.connect();\n    }\n    disconnectContextForScope(scope) {\n        const context = this.contextsByScope.get(scope);\n        if (context) {\n            this.connectedContexts.delete(context);\n            context.disconnect();\n        }\n    }\n    fetchContextForScope(scope) {\n        let context = this.contextsByScope.get(scope);\n        if (!context) {\n            context = new Context(this, scope);\n            this.contextsByScope.set(scope, context);\n        }\n        return context;\n    }\n}\n\nclass ClassMap {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    has(name) {\n        return this.data.has(this.getDataKey(name));\n    }\n    get(name) {\n        return this.getAll(name)[0];\n    }\n    getAll(name) {\n        const tokenString = this.data.get(this.getDataKey(name)) || \"\";\n        return tokenize(tokenString);\n    }\n    getAttributeName(name) {\n        return this.data.getAttributeNameForKey(this.getDataKey(name));\n    }\n    getDataKey(name) {\n        return `${name}-class`;\n    }\n    get data() {\n        return this.scope.data;\n    }\n}\n\nclass DataMap {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get(key) {\n        const name = this.getAttributeNameForKey(key);\n        return this.element.getAttribute(name);\n    }\n    set(key, value) {\n        const name = this.getAttributeNameForKey(key);\n        this.element.setAttribute(name, value);\n        return this.get(key);\n    }\n    has(key) {\n        const name = this.getAttributeNameForKey(key);\n        return this.element.hasAttribute(name);\n    }\n    delete(key) {\n        if (this.has(key)) {\n            const name = this.getAttributeNameForKey(key);\n            this.element.removeAttribute(name);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    getAttributeNameForKey(key) {\n        return `data-${this.identifier}-${dasherize(key)}`;\n    }\n}\n\nclass Guide {\n    constructor(logger) {\n        this.warnedKeysByObject = new WeakMap();\n        this.logger = logger;\n    }\n    warn(object, key, message) {\n        let warnedKeys = this.warnedKeysByObject.get(object);\n        if (!warnedKeys) {\n            warnedKeys = new Set();\n            this.warnedKeysByObject.set(object, warnedKeys);\n        }\n        if (!warnedKeys.has(key)) {\n            warnedKeys.add(key);\n            this.logger.warn(message, object);\n        }\n    }\n}\n\nfunction attributeValueContainsToken(attributeName, token) {\n    return `[${attributeName}~=\"${token}\"]`;\n}\n\nclass TargetSet {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get schema() {\n        return this.scope.schema;\n    }\n    has(targetName) {\n        return this.find(targetName) != null;\n    }\n    find(...targetNames) {\n        return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);\n    }\n    findAll(...targetNames) {\n        return targetNames.reduce((targets, targetName) => [\n            ...targets,\n            ...this.findAllTargets(targetName),\n            ...this.findAllLegacyTargets(targetName),\n        ], []);\n    }\n    findTarget(targetName) {\n        const selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findElement(selector);\n    }\n    findAllTargets(targetName) {\n        const selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector);\n    }\n    getSelectorForTargetName(targetName) {\n        const attributeName = this.schema.targetAttributeForScope(this.identifier);\n        return attributeValueContainsToken(attributeName, targetName);\n    }\n    findLegacyTarget(targetName) {\n        const selector = this.getLegacySelectorForTargetName(targetName);\n        return this.deprecate(this.scope.findElement(selector), targetName);\n    }\n    findAllLegacyTargets(targetName) {\n        const selector = this.getLegacySelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));\n    }\n    getLegacySelectorForTargetName(targetName) {\n        const targetDescriptor = `${this.identifier}.${targetName}`;\n        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);\n    }\n    deprecate(element, targetName) {\n        if (element) {\n            const { identifier } = this;\n            const attributeName = this.schema.targetAttribute;\n            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);\n            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}=\"${identifier}.${targetName}\" with ${revisedAttributeName}=\"${targetName}\". ` +\n                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);\n        }\n        return element;\n    }\n    get guide() {\n        return this.scope.guide;\n    }\n}\n\nclass OutletSet {\n    constructor(scope, controllerElement) {\n        this.scope = scope;\n        this.controllerElement = controllerElement;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get schema() {\n        return this.scope.schema;\n    }\n    has(outletName) {\n        return this.find(outletName) != null;\n    }\n    find(...outletNames) {\n        return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);\n    }\n    findAll(...outletNames) {\n        return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);\n    }\n    getSelectorForOutletName(outletName) {\n        const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);\n        return this.controllerElement.getAttribute(attributeName);\n    }\n    findOutlet(outletName) {\n        const selector = this.getSelectorForOutletName(outletName);\n        if (selector)\n            return this.findElement(selector, outletName);\n    }\n    findAllOutlets(outletName) {\n        const selector = this.getSelectorForOutletName(outletName);\n        return selector ? this.findAllElements(selector, outletName) : [];\n    }\n    findElement(selector, outletName) {\n        const elements = this.scope.queryElements(selector);\n        return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];\n    }\n    findAllElements(selector, outletName) {\n        const elements = this.scope.queryElements(selector);\n        return elements.filter((element) => this.matchesElement(element, selector, outletName));\n    }\n    matchesElement(element, selector, outletName) {\n        const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || \"\";\n        return element.matches(selector) && controllerAttribute.split(\" \").includes(outletName);\n    }\n}\n\nclass Scope {\n    constructor(schema, element, identifier, logger) {\n        this.targets = new TargetSet(this);\n        this.classes = new ClassMap(this);\n        this.data = new DataMap(this);\n        this.containsElement = (element) => {\n            return element.closest(this.controllerSelector) === this.element;\n        };\n        this.schema = schema;\n        this.element = element;\n        this.identifier = identifier;\n        this.guide = new Guide(logger);\n        this.outlets = new OutletSet(this.documentScope, element);\n    }\n    findElement(selector) {\n        return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);\n    }\n    findAllElements(selector) {\n        return [\n            ...(this.element.matches(selector) ? [this.element] : []),\n            ...this.queryElements(selector).filter(this.containsElement),\n        ];\n    }\n    queryElements(selector) {\n        return Array.from(this.element.querySelectorAll(selector));\n    }\n    get controllerSelector() {\n        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);\n    }\n    get isDocumentScope() {\n        return this.element === document.documentElement;\n    }\n    get documentScope() {\n        return this.isDocumentScope\n            ? this\n            : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);\n    }\n}\n\nclass ScopeObserver {\n    constructor(element, schema, delegate) {\n        this.element = element;\n        this.schema = schema;\n        this.delegate = delegate;\n        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);\n        this.scopesByIdentifierByElement = new WeakMap();\n        this.scopeReferenceCounts = new WeakMap();\n    }\n    start() {\n        this.valueListObserver.start();\n    }\n    stop() {\n        this.valueListObserver.stop();\n    }\n    get controllerAttribute() {\n        return this.schema.controllerAttribute;\n    }\n    parseValueForToken(token) {\n        const { element, content: identifier } = token;\n        return this.parseValueForElementAndIdentifier(element, identifier);\n    }\n    parseValueForElementAndIdentifier(element, identifier) {\n        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);\n        let scope = scopesByIdentifier.get(identifier);\n        if (!scope) {\n            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);\n            scopesByIdentifier.set(identifier, scope);\n        }\n        return scope;\n    }\n    elementMatchedValue(element, value) {\n        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;\n        this.scopeReferenceCounts.set(value, referenceCount);\n        if (referenceCount == 1) {\n            this.delegate.scopeConnected(value);\n        }\n    }\n    elementUnmatchedValue(element, value) {\n        const referenceCount = this.scopeReferenceCounts.get(value);\n        if (referenceCount) {\n            this.scopeReferenceCounts.set(value, referenceCount - 1);\n            if (referenceCount == 1) {\n                this.delegate.scopeDisconnected(value);\n            }\n        }\n    }\n    fetchScopesByIdentifierForElement(element) {\n        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);\n        if (!scopesByIdentifier) {\n            scopesByIdentifier = new Map();\n            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);\n        }\n        return scopesByIdentifier;\n    }\n}\n\nclass Router {\n    constructor(application) {\n        this.application = application;\n        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);\n        this.scopesByIdentifier = new Multimap();\n        this.modulesByIdentifier = new Map();\n    }\n    get element() {\n        return this.application.element;\n    }\n    get schema() {\n        return this.application.schema;\n    }\n    get logger() {\n        return this.application.logger;\n    }\n    get controllerAttribute() {\n        return this.schema.controllerAttribute;\n    }\n    get modules() {\n        return Array.from(this.modulesByIdentifier.values());\n    }\n    get contexts() {\n        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);\n    }\n    start() {\n        this.scopeObserver.start();\n    }\n    stop() {\n        this.scopeObserver.stop();\n    }\n    loadDefinition(definition) {\n        this.unloadIdentifier(definition.identifier);\n        const module = new Module(this.application, definition);\n        this.connectModule(module);\n        const afterLoad = definition.controllerConstructor.afterLoad;\n        if (afterLoad) {\n            afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);\n        }\n    }\n    unloadIdentifier(identifier) {\n        const module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            this.disconnectModule(module);\n        }\n    }\n    getContextForElementAndIdentifier(element, identifier) {\n        const module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            return module.contexts.find((context) => context.element == element);\n        }\n    }\n    proposeToConnectScopeForElementAndIdentifier(element, identifier) {\n        const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);\n        if (scope) {\n            this.scopeObserver.elementMatchedValue(scope.element, scope);\n        }\n        else {\n            console.error(`Couldn't find or create scope for identifier: \"${identifier}\" and element:`, element);\n        }\n    }\n    handleError(error, message, detail) {\n        this.application.handleError(error, message, detail);\n    }\n    createScopeForElementAndIdentifier(element, identifier) {\n        return new Scope(this.schema, element, identifier, this.logger);\n    }\n    scopeConnected(scope) {\n        this.scopesByIdentifier.add(scope.identifier, scope);\n        const module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.connectContextForScope(scope);\n        }\n    }\n    scopeDisconnected(scope) {\n        this.scopesByIdentifier.delete(scope.identifier, scope);\n        const module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.disconnectContextForScope(scope);\n        }\n    }\n    connectModule(module) {\n        this.modulesByIdentifier.set(module.identifier, module);\n        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach((scope) => module.connectContextForScope(scope));\n    }\n    disconnectModule(module) {\n        this.modulesByIdentifier.delete(module.identifier);\n        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach((scope) => module.disconnectContextForScope(scope));\n    }\n}\n\nconst defaultSchema = {\n    controllerAttribute: \"data-controller\",\n    actionAttribute: \"data-action\",\n    targetAttribute: \"data-target\",\n    targetAttributeForScope: (identifier) => `data-${identifier}-target`,\n    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,\n    keyMappings: Object.assign(Object.assign({ enter: \"Enter\", tab: \"Tab\", esc: \"Escape\", space: \" \", up: \"ArrowUp\", down: \"ArrowDown\", left: \"ArrowLeft\", right: \"ArrowRight\", home: \"Home\", end: \"End\", page_up: \"PageUp\", page_down: \"PageDown\" }, objectFromEntries(\"abcdefghijklmnopqrstuvwxyz\".split(\"\").map((c) => [c, c]))), objectFromEntries(\"0123456789\".split(\"\").map((n) => [n, n]))),\n};\nfunction objectFromEntries(array) {\n    return array.reduce((memo, [k, v]) => (Object.assign(Object.assign({}, memo), { [k]: v })), {});\n}\n\nclass Application {\n    constructor(element = document.documentElement, schema = defaultSchema) {\n        this.logger = console;\n        this.debug = false;\n        this.logDebugActivity = (identifier, functionName, detail = {}) => {\n            if (this.debug) {\n                this.logFormattedMessage(identifier, functionName, detail);\n            }\n        };\n        this.element = element;\n        this.schema = schema;\n        this.dispatcher = new Dispatcher(this);\n        this.router = new Router(this);\n        this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);\n    }\n    static start(element, schema) {\n        const application = new this(element, schema);\n        application.start();\n        return application;\n    }\n    async start() {\n        await domReady();\n        this.logDebugActivity(\"application\", \"starting\");\n        this.dispatcher.start();\n        this.router.start();\n        this.logDebugActivity(\"application\", \"start\");\n    }\n    stop() {\n        this.logDebugActivity(\"application\", \"stopping\");\n        this.dispatcher.stop();\n        this.router.stop();\n        this.logDebugActivity(\"application\", \"stop\");\n    }\n    register(identifier, controllerConstructor) {\n        this.load({ identifier, controllerConstructor });\n    }\n    registerActionOption(name, filter) {\n        this.actionDescriptorFilters[name] = filter;\n    }\n    load(head, ...rest) {\n        const definitions = Array.isArray(head) ? head : [head, ...rest];\n        definitions.forEach((definition) => {\n            if (definition.controllerConstructor.shouldLoad) {\n                this.router.loadDefinition(definition);\n            }\n        });\n    }\n    unload(head, ...rest) {\n        const identifiers = Array.isArray(head) ? head : [head, ...rest];\n        identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));\n    }\n    get controllers() {\n        return this.router.contexts.map((context) => context.controller);\n    }\n    getControllerForElementAndIdentifier(element, identifier) {\n        const context = this.router.getContextForElementAndIdentifier(element, identifier);\n        return context ? context.controller : null;\n    }\n    handleError(error, message, detail) {\n        var _a;\n        this.logger.error(`%s\\n\\n%o\\n\\n%o`, message, error, detail);\n        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, \"\", 0, 0, error);\n    }\n    logFormattedMessage(identifier, functionName, detail = {}) {\n        detail = Object.assign({ application: this }, detail);\n        this.logger.groupCollapsed(`${identifier} #${functionName}`);\n        this.logger.log(\"details:\", Object.assign({}, detail));\n        this.logger.groupEnd();\n    }\n}\nfunction domReady() {\n    return new Promise((resolve) => {\n        if (document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", () => resolve());\n        }\n        else {\n            resolve();\n        }\n    });\n}\n\nfunction ClassPropertiesBlessing(constructor) {\n    const classes = readInheritableStaticArrayValues(constructor, \"classes\");\n    return classes.reduce((properties, classDefinition) => {\n        return Object.assign(properties, propertiesForClassDefinition(classDefinition));\n    }, {});\n}\nfunction propertiesForClassDefinition(key) {\n    return {\n        [`${key}Class`]: {\n            get() {\n                const { classes } = this;\n                if (classes.has(key)) {\n                    return classes.get(key);\n                }\n                else {\n                    const attribute = classes.getAttributeName(key);\n                    throw new Error(`Missing attribute \"${attribute}\"`);\n                }\n            },\n        },\n        [`${key}Classes`]: {\n            get() {\n                return this.classes.getAll(key);\n            },\n        },\n        [`has${capitalize(key)}Class`]: {\n            get() {\n                return this.classes.has(key);\n            },\n        },\n    };\n}\n\nfunction OutletPropertiesBlessing(constructor) {\n    const outlets = readInheritableStaticArrayValues(constructor, \"outlets\");\n    return outlets.reduce((properties, outletDefinition) => {\n        return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));\n    }, {});\n}\nfunction getOutletController(controller, element, identifier) {\n    return controller.application.getControllerForElementAndIdentifier(element, identifier);\n}\nfunction getControllerAndEnsureConnectedScope(controller, element, outletName) {\n    let outletController = getOutletController(controller, element, outletName);\n    if (outletController)\n        return outletController;\n    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);\n    outletController = getOutletController(controller, element, outletName);\n    if (outletController)\n        return outletController;\n}\nfunction propertiesForOutletDefinition(name) {\n    const camelizedName = namespaceCamelize(name);\n    return {\n        [`${camelizedName}Outlet`]: {\n            get() {\n                const outletElement = this.outlets.find(name);\n                const selector = this.outlets.getSelectorForOutletName(name);\n                if (outletElement) {\n                    const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);\n                    if (outletController)\n                        return outletController;\n                    throw new Error(`The provided outlet element is missing an outlet controller \"${name}\" instance for host controller \"${this.identifier}\"`);\n                }\n                throw new Error(`Missing outlet element \"${name}\" for host controller \"${this.identifier}\". Stimulus couldn't find a matching outlet element using selector \"${selector}\".`);\n            },\n        },\n        [`${camelizedName}Outlets`]: {\n            get() {\n                const outlets = this.outlets.findAll(name);\n                if (outlets.length > 0) {\n                    return outlets\n                        .map((outletElement) => {\n                        const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);\n                        if (outletController)\n                            return outletController;\n                        console.warn(`The provided outlet element is missing an outlet controller \"${name}\" instance for host controller \"${this.identifier}\"`, outletElement);\n                    })\n                        .filter((controller) => controller);\n                }\n                return [];\n            },\n        },\n        [`${camelizedName}OutletElement`]: {\n            get() {\n                const outletElement = this.outlets.find(name);\n                const selector = this.outlets.getSelectorForOutletName(name);\n                if (outletElement) {\n                    return outletElement;\n                }\n                else {\n                    throw new Error(`Missing outlet element \"${name}\" for host controller \"${this.identifier}\". Stimulus couldn't find a matching outlet element using selector \"${selector}\".`);\n                }\n            },\n        },\n        [`${camelizedName}OutletElements`]: {\n            get() {\n                return this.outlets.findAll(name);\n            },\n        },\n        [`has${capitalize(camelizedName)}Outlet`]: {\n            get() {\n                return this.outlets.has(name);\n            },\n        },\n    };\n}\n\nfunction TargetPropertiesBlessing(constructor) {\n    const targets = readInheritableStaticArrayValues(constructor, \"targets\");\n    return targets.reduce((properties, targetDefinition) => {\n        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));\n    }, {});\n}\nfunction propertiesForTargetDefinition(name) {\n    return {\n        [`${name}Target`]: {\n            get() {\n                const target = this.targets.find(name);\n                if (target) {\n                    return target;\n                }\n                else {\n                    throw new Error(`Missing target element \"${name}\" for \"${this.identifier}\" controller`);\n                }\n            },\n        },\n        [`${name}Targets`]: {\n            get() {\n                return this.targets.findAll(name);\n            },\n        },\n        [`has${capitalize(name)}Target`]: {\n            get() {\n                return this.targets.has(name);\n            },\n        },\n    };\n}\n\nfunction ValuePropertiesBlessing(constructor) {\n    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, \"values\");\n    const propertyDescriptorMap = {\n        valueDescriptorMap: {\n            get() {\n                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {\n                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);\n                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);\n                    return Object.assign(result, { [attributeName]: valueDescriptor });\n                }, {});\n            },\n        },\n    };\n    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {\n        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));\n    }, propertyDescriptorMap);\n}\nfunction propertiesForValueDefinitionPair(valueDefinitionPair, controller) {\n    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);\n    const { key, name, reader: read, writer: write } = definition;\n    return {\n        [name]: {\n            get() {\n                const value = this.data.get(key);\n                if (value !== null) {\n                    return read(value);\n                }\n                else {\n                    return definition.defaultValue;\n                }\n            },\n            set(value) {\n                if (value === undefined) {\n                    this.data.delete(key);\n                }\n                else {\n                    this.data.set(key, write(value));\n                }\n            },\n        },\n        [`has${capitalize(name)}`]: {\n            get() {\n                return this.data.has(key) || definition.hasCustomDefaultValue;\n            },\n        },\n    };\n}\nfunction parseValueDefinitionPair([token, typeDefinition], controller) {\n    return valueDescriptorForTokenAndTypeDefinition({\n        controller,\n        token,\n        typeDefinition,\n    });\n}\nfunction parseValueTypeConstant(constant) {\n    switch (constant) {\n        case Array:\n            return \"array\";\n        case Boolean:\n            return \"boolean\";\n        case Number:\n            return \"number\";\n        case Object:\n            return \"object\";\n        case String:\n            return \"string\";\n    }\n}\nfunction parseValueTypeDefault(defaultValue) {\n    switch (typeof defaultValue) {\n        case \"boolean\":\n            return \"boolean\";\n        case \"number\":\n            return \"number\";\n        case \"string\":\n            return \"string\";\n    }\n    if (Array.isArray(defaultValue))\n        return \"array\";\n    if (Object.prototype.toString.call(defaultValue) === \"[object Object]\")\n        return \"object\";\n}\nfunction parseValueTypeObject(payload) {\n    const { controller, token, typeObject } = payload;\n    const hasType = isSomething(typeObject.type);\n    const hasDefault = isSomething(typeObject.default);\n    const fullObject = hasType && hasDefault;\n    const onlyType = hasType && !hasDefault;\n    const onlyDefault = !hasType && hasDefault;\n    const typeFromObject = parseValueTypeConstant(typeObject.type);\n    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);\n    if (onlyType)\n        return typeFromObject;\n    if (onlyDefault)\n        return typeFromDefaultValue;\n    if (typeFromObject !== typeFromDefaultValue) {\n        const propertyPath = controller ? `${controller}.${token}` : token;\n        throw new Error(`The specified default value for the Stimulus Value \"${propertyPath}\" must match the defined type \"${typeFromObject}\". The provided default value of \"${typeObject.default}\" is of type \"${typeFromDefaultValue}\".`);\n    }\n    if (fullObject)\n        return typeFromObject;\n}\nfunction parseValueTypeDefinition(payload) {\n    const { controller, token, typeDefinition } = payload;\n    const typeObject = { controller, token, typeObject: typeDefinition };\n    const typeFromObject = parseValueTypeObject(typeObject);\n    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);\n    const typeFromConstant = parseValueTypeConstant(typeDefinition);\n    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;\n    if (type)\n        return type;\n    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;\n    throw new Error(`Unknown value type \"${propertyPath}\" for \"${token}\" value`);\n}\nfunction defaultValueForDefinition(typeDefinition) {\n    const constant = parseValueTypeConstant(typeDefinition);\n    if (constant)\n        return defaultValuesByType[constant];\n    const hasDefault = hasProperty(typeDefinition, \"default\");\n    const hasType = hasProperty(typeDefinition, \"type\");\n    const typeObject = typeDefinition;\n    if (hasDefault)\n        return typeObject.default;\n    if (hasType) {\n        const { type } = typeObject;\n        const constantFromType = parseValueTypeConstant(type);\n        if (constantFromType)\n            return defaultValuesByType[constantFromType];\n    }\n    return typeDefinition;\n}\nfunction valueDescriptorForTokenAndTypeDefinition(payload) {\n    const { token, typeDefinition } = payload;\n    const key = `${dasherize(token)}-value`;\n    const type = parseValueTypeDefinition(payload);\n    return {\n        type,\n        key,\n        name: camelize(key),\n        get defaultValue() {\n            return defaultValueForDefinition(typeDefinition);\n        },\n        get hasCustomDefaultValue() {\n            return parseValueTypeDefault(typeDefinition) !== undefined;\n        },\n        reader: readers[type],\n        writer: writers[type] || writers.default,\n    };\n}\nconst defaultValuesByType = {\n    get array() {\n        return [];\n    },\n    boolean: false,\n    number: 0,\n    get object() {\n        return {};\n    },\n    string: \"\",\n};\nconst readers = {\n    array(value) {\n        const array = JSON.parse(value);\n        if (!Array.isArray(array)) {\n            throw new TypeError(`expected value of type \"array\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(array)}\"`);\n        }\n        return array;\n    },\n    boolean(value) {\n        return !(value == \"0\" || String(value).toLowerCase() == \"false\");\n    },\n    number(value) {\n        return Number(value.replace(/_/g, \"\"));\n    },\n    object(value) {\n        const object = JSON.parse(value);\n        if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n            throw new TypeError(`expected value of type \"object\" but instead got value \"${value}\" of type \"${parseValueTypeDefault(object)}\"`);\n        }\n        return object;\n    },\n    string(value) {\n        return value;\n    },\n};\nconst writers = {\n    default: writeString,\n    array: writeJSON,\n    object: writeJSON,\n};\nfunction writeJSON(value) {\n    return JSON.stringify(value);\n}\nfunction writeString(value) {\n    return `${value}`;\n}\n\nclass Controller {\n    constructor(context) {\n        this.context = context;\n    }\n    static get shouldLoad() {\n        return true;\n    }\n    static afterLoad(_identifier, _application) {\n        return;\n    }\n    get application() {\n        return this.context.application;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get targets() {\n        return this.scope.targets;\n    }\n    get outlets() {\n        return this.scope.outlets;\n    }\n    get classes() {\n        return this.scope.classes;\n    }\n    get data() {\n        return this.scope.data;\n    }\n    initialize() {\n    }\n    connect() {\n    }\n    disconnect() {\n    }\n    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true, } = {}) {\n        const type = prefix ? `${prefix}:${eventName}` : eventName;\n        const event = new CustomEvent(type, { detail, bubbles, cancelable });\n        target.dispatchEvent(event);\n        return event;\n    }\n}\nController.blessings = [\n    ClassPropertiesBlessing,\n    TargetPropertiesBlessing,\n    ValuePropertiesBlessing,\n    OutletPropertiesBlessing,\n];\nController.targets = [];\nController.outlets = [];\nController.values = {};\n\nexport { Application, AttributeObserver, Context, Controller, ElementObserver, IndexedMultimap, Multimap, SelectorObserver, StringMapObserver, TokenListObserver, ValueListObserver, add, defaultSchema, del, fetch, prune };\n","import { Application } from \"@hotwired/stimulus\"\nimport { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument } from \"../helpers.js\"\n\nexport class StimulusReloader {\n  static async reload(filePattern) {\n    const document = await reloadHtmlDocument()\n    return new StimulusReloader(document, filePattern).reload()\n  }\n\n  constructor(document, filePattern = /./) {\n    this.document = document\n    this.filePattern = filePattern\n    this.application = window.Stimulus || Application.start()\n  }\n\n  async reload() {\n    log(\"Reload Stimulus controllers...\")\n\n    this.application.stop()\n\n    await this.#reloadChangedStimulusControllers()\n    this.#unloadDeletedStimulusControllers()\n\n    this.application.start()\n  }\n\n  async #reloadChangedStimulusControllers() {\n    await Promise.all(\n      this.#stimulusControllerPathsToReload.map(async moduleName => this.#reloadStimulusController(moduleName))\n    )\n  }\n\n  get #stimulusControllerPathsToReload() {\n    this.controllerPathsToReload = this.controllerPathsToReload || this.#stimulusControllerPaths.filter(path => this.#shouldReloadController(path))\n    return this.controllerPathsToReload\n  }\n\n  get #stimulusControllerPaths() {\n    return Object.keys(this.#stimulusPathsByModule).filter(path => path.endsWith(\"_controller\"))\n  }\n\n  #shouldReloadController(path) {\n    return this.filePattern.test(path)\n  }\n\n  get #stimulusPathsByModule() {\n    this.pathsByModule = this.pathsByModule || this.#parseImportmapJson()\n    return this.pathsByModule\n  }\n\n  #parseImportmapJson() {\n    const importmapScript = this.document.querySelector(\"script[type=importmap]\")\n    return JSON.parse(importmapScript.text).imports\n  }\n\n  async #reloadStimulusController(moduleName) {\n    log(`\\t${moduleName}`)\n\n    const controllerName = this.#extractControllerName(moduleName)\n    const path = cacheBustedUrl(this.#pathForModuleName(moduleName))\n\n    const module = await import(path)\n\n    this.#registerController(controllerName, module)\n  }\n\n  #unloadDeletedStimulusControllers() {\n    this.#controllersToUnload.forEach(controller => this.#deregisterController(controller.identifier))\n  }\n\n  get #controllersToUnload() {\n    if (this.#didChangeTriggerAReload) {\n      return []\n    } else {\n      return this.application.controllers.filter(controller => this.filePattern.test(`${controller.identifier}_controller`))\n    }\n  }\n\n  get #didChangeTriggerAReload() {\n    return this.#stimulusControllerPathsToReload.length > 0\n  }\n\n  #pathForModuleName(moduleName) {\n    return this.#stimulusPathsByModule[moduleName]\n  }\n\n  #extractControllerName(path) {\n    return path\n      .replace(/^.*\\//, \"\")\n      .replace(\"_controller\", \"\")\n      .replace(/\\//g, \"--\")\n      .replace(/_/g, \"-\")\n  }\n\n  #registerController(name, module) {\n    this.application.unload(name)\n    this.application.register(name, module.default)\n  }\n\n  #deregisterController(name) {\n    log(`\\tRemoving controller ${name}`)\n    this.application.unload(name)\n  }\n}\n","import { Idiomorph } from \"idiomorph/dist/idiomorph.esm.js\"\nimport { log } from \"../logger.js\"\nimport { reloadHtmlDocument } from \"../helpers.js\"\nimport { StimulusReloader } from \"./stimulus_reloader.js\"\n\nexport class HtmlReloader {\n  static async reload() {\n    return new HtmlReloader().reload()\n  }\n\n  async reload() {\n    const reloadedDocument = await this.#reloadHtml()\n    await this.#reloadStimulus(reloadedDocument)\n  }\n\n  async #reloadHtml() {\n    log(\"Reload html...\")\n\n    const reloadedDocument = await reloadHtmlDocument()\n    this.#updateBody(reloadedDocument.body)\n    return reloadedDocument\n  }\n\n  #updateBody(newBody) {\n    Idiomorph.morph(document.body, newBody)\n  }\n\n  async #reloadStimulus(reloadedDocument) {\n    return new StimulusReloader(reloadedDocument).reload()\n  }\n}\n","import { log } from \"../logger.js\"\nimport { cacheBustedUrl, reloadHtmlDocument, pathWithoutAssetDigest } from \"../helpers.js\"\n\nexport class CssReloader {\n  static async reload(...params) {\n    return new CssReloader(...params).reload()\n  }\n\n  constructor(filePattern = /./) {\n    this.filePattern = filePattern\n  }\n\n  async reload() {\n    log(\"Reload css...\")\n    await Promise.all(await this.#reloadAllLinks())\n  }\n\n  async #reloadAllLinks() {\n    const cssLinks = await this.#loadNewCssLinks();\n    return cssLinks.map(link => this.#reloadLinkIfNeeded(link))\n  }\n\n  async #loadNewCssLinks() {\n    const reloadedDocument = await reloadHtmlDocument()\n    return Array.from(reloadedDocument.head.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #reloadLinkIfNeeded(link) {\n    if (this.#shouldReloadLink(link)) {\n      return this.#reloadLink(link)\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  #shouldReloadLink(link) {\n    return this.filePattern.test(link.getAttribute(\"href\"))\n  }\n\n  async #reloadLink(link) {\n    return new Promise(resolve => {\n      const href = link.getAttribute(\"href\")\n      const newLink = this.#findExistingLinkFor(link) || this.#appendNewLink(link)\n\n      newLink.setAttribute(\"href\", cacheBustedUrl(link.getAttribute(\"href\")))\n      newLink.onload = () => {\n        log(`\\t${href}`)\n        resolve()\n      }\n    })\n  }\n\n  #findExistingLinkFor(link) {\n    return this.#cssLinks.find(newLink => pathWithoutAssetDigest(link.href) === pathWithoutAssetDigest(newLink.href))\n  }\n\n  get #cssLinks() {\n    return Array.from(document.querySelectorAll(\"link[rel='stylesheet']\"))\n  }\n\n  #appendNewLink(link) {\n    document.head.append(link)\n    return link\n  }\n}\n","import consumer from \"./consumer\"\nimport { assetNameFromPath } from \"../helpers.js\";\nimport { HtmlReloader } from \"../reloaders/html_reloader.js\";\nimport { CssReloader } from \"../reloaders/css_reloader.js\";\nimport { StimulusReloader } from \"../reloaders/stimulus_reloader.js\";\n\nconsumer.subscriptions.create({ channel: \"Hotwire::Spark::Channel\" }, {\n  connected() {\n    document.body.setAttribute(\"data-hotwire-spark-ready\", \"\")\n  },\n\n  async received(message) {\n    try {\n      await this.dispatch(message)\n    } catch(error) {\n      console.log(`Error on ${message.action}`, error)\n    }\n  },\n\n  dispatch({ action, path }) {\n    const fileName = assetNameFromPath(path)\n\n    switch(action) {\n      case \"reload_html\":\n        return this.reloadHtml()\n      case \"reload_css\":\n        return this.reloadCss(fileName)\n      case \"reload_stimulus\":\n        return this.reloadStimulus(fileName)\n      default:\n        throw new Error(`Unknown action: ${action}`)\n    }\n  },\n\n  reloadHtml() {\n    return HtmlReloader.reload()\n  },\n\n  reloadCss(fileName) {\n    return CssReloader.reload(new RegExp(fileName))\n  },\n\n  reloadStimulus(fileName) {\n    return StimulusReloader.reload(new RegExp(fileName))\n  }\n})\n\n","import \"./channels/monitoring_channel.js\"\nimport { getConfigurationProperty } from \"./helpers.js\";\n\nconst HotwireSpark = {\n  config: {\n    loggingEnabled: false \n  }\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  HotwireSpark.config.loggingEnabled = getConfigurationProperty(\"logging\");\n})\n\nexport default HotwireSpark\n"],"names":["adapters","logger","console","undefined","WebSocket","log","messages","this","enabled","push","Date","now","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","staleThreshold","stop","stopPolling","removeEventListener","recordMessage","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","getPollInterval","reconnectionBackoffRate","Math","pow","min","random","connectionIsStale","refreshedAt","disconnectedRecently","reopen","document","visibilityState","isOpen","INTERNAL","message_types","welcome","disconnect","ping","confirmation","rejection","disconnect_reasons","unauthorized","invalid_request","server_restart","remote","default_mount_path","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","socketProtocols","subprotocols","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","triedToReconnect","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","reconnectAttempted","reload","confirmSubscription","notify","reconnected","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","SubscriptionGuarantor","pendingSubscriptions","guarantee","subscription","startGuaranteeing","forget","filter","s","stopGuaranteeing","retrySubscribing","retryTimeout","subscribe","map","Subscriptions","guarantor","create","channelName","channel","add","ensureActiveConnection","findAll","sendCommand","callbackName","args","Consumer","_url","test","a","createElement","href","replace","createWebSocketURL","connect","addSubProtocol","subprotocol","createConsumer","name","element","head","querySelector","getAttribute","getConfig","pathWithoutAssetDigest","path","urlWithParams","urlString","URL","window","location","origin","Object","entries","forEach","_ref","searchParams","set","toString","cacheBustedUrl","async","reloadHtmlDocument","currentUrl","hotwire_spark","response","fetch","headers","Accept","ok","Error","status","fetchedHTML","text","DOMParser","parseFromString","Idiomorph","EMPTY_SET","Set","defaults","morphStyle","callbacks","beforeNodeAdded","noOp","afterNodeAdded","beforeNodeMorphed","afterNodeMorphed","beforeNodeRemoved","afterNodeRemoved","beforeAttributeUpdated","style","shouldPreserve","elt","shouldReAppend","shouldRemove","afterHeadMorphed","morphNormalizedContent","oldNode","normalizedNewContent","ctx","block","oldHead","newHead","promises","handleHeadElement","Promise","all","then","assign","ignore","morphChildren","children","bestMatch","newContent","currentElement","firstChild","bestElement","score","newScore","scoreElement","nextSibling","findBestNodeMatch","previousSibling","morphedNode","morphOldNodeTo","stack","added","node","pop","parentElement","insertBefore","insertSiblings","ignoreValueOfActiveElement","possibleActiveElement","ignoreActiveValue","activeElement","ignoreActive","isSoftMatch","HTMLHeadElement","from","to","nodeType","fromAttributes","attributes","toAttributes","fromAttribute","ignoreAttribute","setAttribute","i","toAttribute","hasAttribute","removeAttribute","nodeValue","HTMLInputElement","fromValue","toValue","syncBooleanAttribute","HTMLOptionElement","HTMLTextAreaElement","syncInputValue","syncNodeFrom","replaceChild","newParent","oldParent","newChild","nextNewChild","insertionPoint","appendChild","removeIdsFromConsideration","isIdSetMatch","idSetMatch","findIdSetMatch","removeNodesBetween","softMatch","findSoftMatch","tempNode","removeNode","attr","updateType","attributeName","ignoreUpdate","newHeadTag","currentHead","removed","preserved","nodesToAppend","headMergeStyle","srcToNewHeadNodes","Map","newHeadChild","outerHTML","currentHeadElt","inNewContent","has","isReAppended","isPreserved","delete","values","newNode","newElt","createRange","createContextualFragment","src","resolve","promise","_resolve","removedElement","removeChild","kept","node1","node2","tagName","id","getIdIntersectionCount","startInclusive","endExclusive","newChildPotentialIdCount","potentialMatch","otherMatchCount","potentialSoftMatch","siblingSoftMatchCount","isIdInConsideration","deadIds","idIsWithinNode","targetNode","idMap","get","idSet","sourceSet","matchCount","populateIdMapForNode","nodeParent","idElements","querySelectorAll","current","createIdMap","oldContent","morph","config","Document","documentElement","parser","contentWithSvgsRemoved","match","content","generatedByIdiomorph","htmlElement","body","parseContent","normalizedContent","Node","dummyParent","append","normalizeContent","finalConfig","mergeDefaults","target","createMorphContext","HotwireSpark","loggingEnabled","_len","arguments","Array","_key","EventListener","eventTarget","eventOptions","unorderedBindings","bindingConnected","binding","bindingDisconnected","handleEvent","extendedEvent","stopImmediatePropagation","immediatePropagationStopped","extendEvent","bindings","hasBindings","size","sort","left","right","leftIndex","index","rightIndex","Dispatcher","application","eventListenerMaps","started","eventListeners","eventListener","reduce","listeners","concat","fetchEventListenerForBinding","clearEventListeners","clearEventListenersForBinding","handleError","detail","removeMappedEventListenerFor","eventListenerMap","fetchEventListenerMapForEventTarget","cacheKey","fetchEventListener","createEventListener","parts","keys","join","defaultActionDescriptorFilters","stopPropagation","prevent","preventDefault","self","descriptorPattern","parseEventTarget","eventTargetName","camelize","_","char","toUpperCase","namespaceCamelize","allModifiers","Action","descriptor","schema","defaultEventNames","getDefaultEventNameForElement","methodName","keyFilter","forToken","token","descriptorString","matches","trim","includes","split","options","parseActionDescriptorString","eventFilter","shouldIgnoreKeyboardEvent","filters","keyFilterDissatisfied","standardFilter","keyMappings","property","hasOwnProperty","shouldIgnoreMouseEvent","pattern","RegExp","typecast","meta","ctrl","alt","shift","modifier","metaKey","ctrlKey","altKey","shiftKey","button","form","details","input","e","select","textarea","o_O","Binding","context","actionEvent","prepareActionEvent","willBeInvokedByEvent","applyEventModifiers","invokeWithEvent","method","controller","actionDescriptorFilters","passes","currentTarget","logDebugActivity","KeyboardEvent","MouseEvent","Element","contains","scope","containsElement","ElementObserver","delegate","mutationObserverInit","childList","subtree","elements","mutationObserver","MutationObserver","mutations","processMutations","observe","refresh","pause","callback","takeRecords","matchElementsInTree","removeElement","addElement","mutation","processMutation","processAttributeChange","processRemovedNodes","removedNodes","processAddedNodes","addedNodes","elementAttributeChanged","matchElement","nodes","elementFromNode","processTree","elementIsActive","tree","processor","ELEMENT_NODE","isConnected","elementMatched","elementUnmatched","AttributeObserver","elementObserver","selector","elementMatchedAttribute","elementUnmatchedAttribute","elementAttributeValueChanged","Multimap","valuesByKey","prune","del","hasKey","hasValue","some","getValuesForKey","getKeysForValue","_values","SelectorObserver","_selector","matchesByElement","selectorMatchElement","selectorMatched","selectors","selectorUnmatched","_attributeName","matchedBefore","StringMapObserver","stringMap","attributeOldValue","knownAttributeNames","refreshAttribute","oldValue","getStringMapKeyForAttribute","stringMapKeyAdded","stringMapValueChanged","stringMapKeyRemoved","currentAttributeNames","recordedAttributeNames","attribute","TokenListObserver","attributeObserver","tokensByElement","tokensMatched","readTokensForElement","unmatchedTokens","matchedTokens","refreshTokensForElement","tokensUnmatched","tokens","tokenMatched","tokenUnmatched","previousTokens","currentTokens","firstDifferingIndex","max","zip","findIndex","previousToken","currentToken","tokenString","parseTokenString","ValueListObserver","tokenListObserver","parseResultsByToken","WeakMap","valuesByTokenByElement","fetchParseResultForToken","fetchValuesByTokenForElement","elementMatchedValue","elementUnmatchedValue","parseResult","parseToken","valuesByToken","parseValueForToken","BindingObserver","bindingsByAction","valueListObserver","actionAttribute","disconnectAllActions","connectAction","disconnectAction","clear","ValueObserver","receiver","stringMapObserver","valueDescriptorMap","invokeChangedCallbacksForDefaultValues","invokeChangedCallback","writer","defaultValue","valueDescriptorNameMap","valueDescriptors","rawValue","rawOldValue","changedMethodName","changedMethod","reader","TypeError","descriptors","hasMethodName","charAt","TargetObserver","targetsByName","disconnectAllTargets","connectTarget","disconnectTarget","_a","targetConnected","targetDisconnected","readInheritableStaticArrayValues","propertyName","ancestors","getPrototypeOf","reverse","getAncestorsForConstructor","definition","isArray","getOwnStaticArrayValues","OutletObserver","outletsByName","outletElementsByName","selectorObserverMap","attributeObserverMap","outletDefinitions","outletName","setupSelectorObserverForOutlet","setupAttributeObserverForOutlet","dependentContexts","observer","disconnectAllOutlets","stopSelectorObservers","stopAttributeObservers","outlet","getOutlet","connectOutlet","getOutletFromMap","disconnectOutlet","hasOutlet","hasOutletController","controllerAttribute","_element","getOutletNameFromOutletAttributeName","updateSelectorObserverForOutlet","outletConnected","outletDisconnected","selectorObserver","attributeNameForOutletName","outlets","getSelectorForOutletName","outletAttributeForScope","find","outletDependencies","dependencies","router","modules","module","controllerConstructor","dependentControllerIdentifiers","identifiers","contexts","getControllerForElementAndIdentifier","Context","functionName","bindingObserver","dispatcher","valueObserver","targetObserver","outletObserver","initialize","invokeControllerMethod","bless","shadowConstructor","shadowProperties","getOwnKeys","shadowingDescriptor","getOwnPropertyDescriptor","getShadowedDescriptor","getShadowProperties","defineProperties","shadow","blessings","blessedProperties","blessing","getBlessedProperties","getOwnPropertySymbols","getOwnPropertyNames","extendWithReflect","extended","Reflect","construct","setPrototypeOf","b","testReflectExtension","Module","blessDefinition","contextsByScope","connectedContexts","connectContextForScope","fetchContextForScope","disconnectContextForScope","ClassMap","getDataKey","getAll","getAttributeName","getAttributeNameForKey","DataMap","Guide","warnedKeysByObject","warn","warnedKeys","attributeValueContainsToken","TargetSet","targetName","targetNames","findTarget","findLegacyTarget","targets","findAllTargets","findAllLegacyTargets","getSelectorForTargetName","findElement","findAllElements","targetAttributeForScope","getLegacySelectorForTargetName","deprecate","targetDescriptor","targetAttribute","revisedAttributeName","guide","OutletSet","controllerElement","outletNames","findOutlet","findAllOutlets","queryElements","matchesElement","Scope","classes","closest","controllerSelector","documentScope","isDocumentScope","ScopeObserver","scopesByIdentifierByElement","scopeReferenceCounts","parseValueForElementAndIdentifier","scopesByIdentifier","fetchScopesByIdentifierForElement","createScopeForElementAndIdentifier","referenceCount","scopeConnected","scopeDisconnected","Router","scopeObserver","modulesByIdentifier","loadDefinition","unloadIdentifier","connectModule","afterLoad","disconnectModule","getContextForElementAndIdentifier","proposeToConnectScopeForElementAndIdentifier","defaultSchema","enter","tab","esc","space","up","down","home","end","page_up","page_down","objectFromEntries","c","n","array","memo","k","v","Application","debug","logFormattedMessage","register","load","registerActionOption","rest","shouldLoad","unload","controllers","onerror","groupCollapsed","groupEnd","StimulusReloader","filePattern","Stimulus","reloadChangedStimulusControllers","unloadDeletedStimulusControllers","stimulusControllerPathsToReload","reloadStimulusController","moduleName","controllerPathsToReload","stimulusControllerPaths","shouldReloadController","stimulusPathsByModule","endsWith","pathsByModule","parseImportmapJson","importmapScript","imports","controllerName","extractControllerName","pathForModuleName","import","registerController","controllersToUnload","deregisterController","didChangeTriggerAReload","default","HtmlReloader","reloadedDocument","reloadHtml","reloadStimulus","updateBody","newBody","CssReloader","reloadAllLinks","loadNewCssLinks","link","reloadLinkIfNeeded","shouldReloadLink","reloadLink","newLink","findExistingLinkFor","appendNewLink","onload","cssLinks","connected","received","dispatch","fileName","assetNameFromPath","reloadCss"],"mappings":"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","x_google_ignoreList":[0,3,5]}